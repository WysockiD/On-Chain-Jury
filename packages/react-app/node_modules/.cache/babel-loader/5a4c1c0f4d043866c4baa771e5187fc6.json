{"ast":null,"code":"\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphql = require(\"graphql\");\n\nvar _jsonParse = _interopRequireDefault(require(\"../utils/jsonParse\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Registers a \"lint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n * Given the text within an editor, this helper will take that text and return\n * a list of linter issues ensuring that correct variables were provided.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n */\n\n\n_codemirror.default.registerHelper('lint', 'graphql-variables', (text, options, editor) => {\n  // If there's no text, do nothing.\n  if (!text) {\n    return [];\n  } // First, linter needs to determine if there are any parsing errors.\n\n\n  let ast;\n\n  try {\n    ast = (0, _jsonParse.default)(text);\n  } catch (syntaxError) {\n    if (syntaxError.stack) {\n      throw syntaxError;\n    }\n\n    return [lintError(editor, syntaxError, syntaxError.message)];\n  } // If there are not yet known variables, do nothing.\n\n\n  const variableToType = options.variableToType;\n\n  if (!variableToType) {\n    return [];\n  } // Then highlight any issues with the provided variables.\n\n\n  return validateVariables(editor, variableToType, ast);\n}); // Given a variableToType object, a source text, and a JSON AST, produces a\n// list of CodeMirror annotations for any variable validation errors.\n\n\nfunction validateVariables(editor, variableToType, variablesAST) {\n  const errors = [];\n  variablesAST.members.forEach(member => {\n    const variableName = member.key.value;\n    const type = variableToType[variableName];\n\n    if (!type) {\n      errors.push(lintError(editor, member.key, `Variable \"$${variableName}\" does not appear in any GraphQL query.`));\n    } else {\n      validateValue(type, member.value).forEach(([node, message]) => {\n        errors.push(lintError(editor, node, message));\n      });\n    }\n  });\n  return errors;\n} // Returns a list of validation errors in the form Array<[Node, String]>.\n\n\nfunction validateValue(type, valueAST) {\n  // Validate non-nullable values.\n  if (type instanceof _graphql.GraphQLNonNull) {\n    if (valueAST.kind === 'Null') {\n      return [[valueAST, `Type \"${type}\" is non-nullable and cannot be null.`]];\n    }\n\n    return validateValue(type.ofType, valueAST);\n  }\n\n  if (valueAST.kind === 'Null') {\n    return [];\n  } // Validate lists of values, accepting a non-list as a list of one.\n\n\n  if (type instanceof _graphql.GraphQLList) {\n    const itemType = type.ofType;\n\n    if (valueAST.kind === 'Array') {\n      return mapCat(valueAST.values, item => validateValue(itemType, item));\n    }\n\n    return validateValue(itemType, valueAST);\n  } // Validate input objects.\n\n\n  if (type instanceof _graphql.GraphQLInputObjectType) {\n    if (valueAST.kind !== 'Object') {\n      return [[valueAST, `Type \"${type}\" must be an Object.`]];\n    } // Validate each field in the input object.\n\n\n    const providedFields = Object.create(null);\n    const fieldErrors = mapCat(valueAST.members, member => {\n      const fieldName = member.key.value;\n      providedFields[fieldName] = true;\n      const inputField = type.getFields()[fieldName];\n\n      if (!inputField) {\n        return [[member.key, `Type \"${type}\" does not have a field \"${fieldName}\".`]];\n      }\n\n      const fieldType = inputField ? inputField.type : undefined;\n      return validateValue(fieldType, member.value);\n    }); // Look for missing non-nullable fields.\n\n    Object.keys(type.getFields()).forEach(fieldName => {\n      if (!providedFields[fieldName]) {\n        const fieldType = type.getFields()[fieldName].type;\n\n        if (fieldType instanceof _graphql.GraphQLNonNull) {\n          fieldErrors.push([valueAST, `Object of type \"${type}\" is missing required field \"${fieldName}\".`]);\n        }\n      }\n    });\n    return fieldErrors;\n  } // Validate common scalars.\n\n\n  if (type.name === 'Boolean' && valueAST.kind !== 'Boolean' || type.name === 'String' && valueAST.kind !== 'String' || type.name === 'ID' && valueAST.kind !== 'Number' && valueAST.kind !== 'String' || type.name === 'Float' && valueAST.kind !== 'Number' || type.name === 'Int' && ( // eslint-disable-next-line no-bitwise\n  valueAST.kind !== 'Number' || (valueAST.value | 0) !== valueAST.value)) {\n    return [[valueAST, `Expected value of type \"${type}\".`]];\n  } // Validate enums and custom scalars.\n\n\n  if (type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLScalarType) {\n    if (valueAST.kind !== 'String' && valueAST.kind !== 'Number' && valueAST.kind !== 'Boolean' && valueAST.kind !== 'Null' || isNullish(type.parseValue(valueAST.value))) {\n      return [[valueAST, `Expected value of type \"${type}\".`]];\n    }\n  }\n\n  return [];\n} // Give a parent text, an AST node with location, and a message, produces a\n// CodeMirror annotation object.\n\n\nfunction lintError(editor, node, message) {\n  return {\n    message,\n    severity: 'error',\n    type: 'validation',\n    from: editor.posFromIndex(node.start),\n    to: editor.posFromIndex(node.end)\n  };\n}\n\nfunction isNullish(value) {\n  // eslint-disable-next-line no-self-compare\n  return value === null || value === undefined || value !== value;\n}\n\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}","map":{"version":3,"sources":["/home/dylan/scaffold-eth/node_modules/codemirror-graphql/variables/lint.js"],"names":["_codemirror","_interopRequireDefault","require","_graphql","_jsonParse","obj","__esModule","default","registerHelper","text","options","editor","ast","syntaxError","stack","lintError","message","variableToType","validateVariables","variablesAST","errors","members","forEach","member","variableName","key","value","type","push","validateValue","node","valueAST","GraphQLNonNull","kind","ofType","GraphQLList","itemType","mapCat","values","item","GraphQLInputObjectType","providedFields","Object","create","fieldErrors","fieldName","inputField","getFields","fieldType","undefined","keys","name","GraphQLEnumType","GraphQLScalarType","isNullish","parseValue","severity","from","posFromIndex","start","to","end","array","mapper","Array","prototype","concat","apply","map"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphql = require(\"graphql\");\n\nvar _jsonParse = _interopRequireDefault(require(\"../utils/jsonParse\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Registers a \"lint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n * Given the text within an editor, this helper will take that text and return\n * a list of linter issues ensuring that correct variables were provided.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n */\n_codemirror.default.registerHelper('lint', 'graphql-variables', (text, options, editor) => {\n  // If there's no text, do nothing.\n  if (!text) {\n    return [];\n  } // First, linter needs to determine if there are any parsing errors.\n\n\n  let ast;\n\n  try {\n    ast = (0, _jsonParse.default)(text);\n  } catch (syntaxError) {\n    if (syntaxError.stack) {\n      throw syntaxError;\n    }\n\n    return [lintError(editor, syntaxError, syntaxError.message)];\n  } // If there are not yet known variables, do nothing.\n\n\n  const variableToType = options.variableToType;\n\n  if (!variableToType) {\n    return [];\n  } // Then highlight any issues with the provided variables.\n\n\n  return validateVariables(editor, variableToType, ast);\n}); // Given a variableToType object, a source text, and a JSON AST, produces a\n// list of CodeMirror annotations for any variable validation errors.\n\n\nfunction validateVariables(editor, variableToType, variablesAST) {\n  const errors = [];\n  variablesAST.members.forEach(member => {\n    const variableName = member.key.value;\n    const type = variableToType[variableName];\n\n    if (!type) {\n      errors.push(lintError(editor, member.key, `Variable \"$${variableName}\" does not appear in any GraphQL query.`));\n    } else {\n      validateValue(type, member.value).forEach(([node, message]) => {\n        errors.push(lintError(editor, node, message));\n      });\n    }\n  });\n  return errors;\n} // Returns a list of validation errors in the form Array<[Node, String]>.\n\n\nfunction validateValue(type, valueAST) {\n  // Validate non-nullable values.\n  if (type instanceof _graphql.GraphQLNonNull) {\n    if (valueAST.kind === 'Null') {\n      return [[valueAST, `Type \"${type}\" is non-nullable and cannot be null.`]];\n    }\n\n    return validateValue(type.ofType, valueAST);\n  }\n\n  if (valueAST.kind === 'Null') {\n    return [];\n  } // Validate lists of values, accepting a non-list as a list of one.\n\n\n  if (type instanceof _graphql.GraphQLList) {\n    const itemType = type.ofType;\n\n    if (valueAST.kind === 'Array') {\n      return mapCat(valueAST.values, item => validateValue(itemType, item));\n    }\n\n    return validateValue(itemType, valueAST);\n  } // Validate input objects.\n\n\n  if (type instanceof _graphql.GraphQLInputObjectType) {\n    if (valueAST.kind !== 'Object') {\n      return [[valueAST, `Type \"${type}\" must be an Object.`]];\n    } // Validate each field in the input object.\n\n\n    const providedFields = Object.create(null);\n    const fieldErrors = mapCat(valueAST.members, member => {\n      const fieldName = member.key.value;\n      providedFields[fieldName] = true;\n      const inputField = type.getFields()[fieldName];\n\n      if (!inputField) {\n        return [[member.key, `Type \"${type}\" does not have a field \"${fieldName}\".`]];\n      }\n\n      const fieldType = inputField ? inputField.type : undefined;\n      return validateValue(fieldType, member.value);\n    }); // Look for missing non-nullable fields.\n\n    Object.keys(type.getFields()).forEach(fieldName => {\n      if (!providedFields[fieldName]) {\n        const fieldType = type.getFields()[fieldName].type;\n\n        if (fieldType instanceof _graphql.GraphQLNonNull) {\n          fieldErrors.push([valueAST, `Object of type \"${type}\" is missing required field \"${fieldName}\".`]);\n        }\n      }\n    });\n    return fieldErrors;\n  } // Validate common scalars.\n\n\n  if (type.name === 'Boolean' && valueAST.kind !== 'Boolean' || type.name === 'String' && valueAST.kind !== 'String' || type.name === 'ID' && valueAST.kind !== 'Number' && valueAST.kind !== 'String' || type.name === 'Float' && valueAST.kind !== 'Number' || type.name === 'Int' && ( // eslint-disable-next-line no-bitwise\n  valueAST.kind !== 'Number' || (valueAST.value | 0) !== valueAST.value)) {\n    return [[valueAST, `Expected value of type \"${type}\".`]];\n  } // Validate enums and custom scalars.\n\n\n  if (type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLScalarType) {\n    if (valueAST.kind !== 'String' && valueAST.kind !== 'Number' && valueAST.kind !== 'Boolean' && valueAST.kind !== 'Null' || isNullish(type.parseValue(valueAST.value))) {\n      return [[valueAST, `Expected value of type \"${type}\".`]];\n    }\n  }\n\n  return [];\n} // Give a parent text, an AST node with location, and a message, produces a\n// CodeMirror annotation object.\n\n\nfunction lintError(editor, node, message) {\n  return {\n    message,\n    severity: 'error',\n    type: 'validation',\n    from: editor.posFromIndex(node.start),\n    to: editor.posFromIndex(node.end)\n  };\n}\n\nfunction isNullish(value) {\n  // eslint-disable-next-line no-self-compare\n  return value === null || value === undefined || value !== value;\n}\n\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}"]},"metadata":{},"sourceType":"script"}