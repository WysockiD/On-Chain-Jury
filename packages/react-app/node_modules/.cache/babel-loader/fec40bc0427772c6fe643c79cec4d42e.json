{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = hintList;\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n// Create the expected hint response given a possible list and a token\n\nfunction hintList(cursor, token, list) {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n\n  if (!hints) {\n    return;\n  }\n\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  return {\n    list: hints,\n    from: {\n      line: cursor.line,\n      column: tokenStart\n    },\n    to: {\n      line: cursor.line,\n      column: token.end\n    }\n  };\n} // Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\n\n\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry\n  }));\n  const conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, pair => pair.proximity <= 2), pair => !pair.entry.isDeprecated);\n  const sortedMatches = conciseMatches.sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length);\n  return sortedMatches.map(pair => pair.entry);\n} // Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\n\n\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, '');\n} // Determine a numeric proximity for a suggestion based on current text.\n\n\nfunction getProximity(suggestion, text) {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1; // penalize suggestions not starting with this phrase\n\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n\n  return proximity;\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\n\n\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}","map":{"version":3,"sources":["/home/dylan/Desktop/JuryDapp/node_modules/codemirror-graphql/utils/hintList.js"],"names":["Object","defineProperty","exports","value","default","hintList","cursor","token","list","hints","filterAndSortList","normalizeText","string","tokenStart","type","test","start","end","from","line","column","to","text","filterNonEmpty","entry","isDeprecated","byProximity","map","proximity","getProximity","conciseMatches","pair","sortedMatches","sort","a","b","length","array","predicate","filtered","filter","toLowerCase","replace","suggestion","lexicalDistance","indexOf","i","j","d","aLength","bLength","cost","Math","min"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = hintList;\n\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n// Create the expected hint response given a possible list and a token\nfunction hintList(cursor, token, list) {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n\n  if (!hints) {\n    return;\n  }\n\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  return {\n    list: hints,\n    from: {\n      line: cursor.line,\n      column: tokenStart\n    },\n    to: {\n      line: cursor.line,\n      column: token.end\n    }\n  };\n} // Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\n\n\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry\n  }));\n  const conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, pair => pair.proximity <= 2), pair => !pair.entry.isDeprecated);\n  const sortedMatches = conciseMatches.sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length);\n  return sortedMatches.map(pair => pair.entry);\n} // Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\n\n\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, '');\n} // Determine a numeric proximity for a suggestion based on current text.\n\n\nfunction getProximity(suggestion, text) {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1; // penalize suggestions not starting with this phrase\n\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n\n  return proximity;\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\n\n\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}"]},"metadata":{},"sourceType":"script"}