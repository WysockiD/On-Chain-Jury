{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { TypeInfo, getNamedType, visit, visitWithTypeInfo } from 'graphql';\nexport function uniqueBy(array, iteratee) {\n  var FilteredMap = new Map();\n  var result = [];\n\n  for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n    var item = array_1[_i];\n\n    if (item.kind === 'Field') {\n      var uniqueValue = iteratee(item);\n      var existing = FilteredMap.get(uniqueValue);\n\n      if (item.directives && item.directives.length) {\n        var itemClone = __assign({}, item);\n\n        result.push(itemClone);\n      } else if (existing && existing.selectionSet && item.selectionSet) {\n        existing.selectionSet.selections = __spreadArrays(existing.selectionSet.selections, item.selectionSet.selections);\n      } else if (!existing) {\n        var itemClone = __assign({}, item);\n\n        FilteredMap.set(uniqueValue, itemClone);\n        result.push(itemClone);\n      }\n    } else {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\nexport function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {\n  var _a;\n\n  var selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;\n  var outputSelections = [];\n  var seenSpreads = [];\n\n  for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n    var selection = selections_1[_i];\n\n    if (selection.kind === 'FragmentSpread') {\n      var fragmentName = selection.name.value;\n\n      if (!selection.directives || selection.directives.length === 0) {\n        if (seenSpreads.indexOf(fragmentName) >= 0) {\n          continue;\n        } else {\n          seenSpreads.push(fragmentName);\n        }\n      }\n\n      var fragmentDefinition = fragmentDefinitions[selection.name.value];\n\n      if (fragmentDefinition) {\n        var typeCondition = fragmentDefinition.typeCondition,\n            directives = fragmentDefinition.directives,\n            selectionSet = fragmentDefinition.selectionSet;\n        selection = {\n          kind: 'InlineFragment',\n          typeCondition: typeCondition,\n          directives: directives,\n          selectionSet: selectionSet\n        };\n      }\n    }\n\n    if (selection.kind === 'InlineFragment' && (!selection.directives || ((_a = selection.directives) === null || _a === void 0 ? void 0 : _a.length) === 0)) {\n      var fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;\n\n      if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\n        outputSelections.push.apply(outputSelections, inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType));\n        continue;\n      }\n    }\n\n    outputSelections.push(selection);\n  }\n\n  return outputSelections;\n}\nexport default function mergeAST(documentAST, schema) {\n  var typeInfo = schema ? new TypeInfo(schema) : null;\n  var fragmentDefinitions = Object.create(null);\n\n  for (var _i = 0, _a = documentAST.definitions; _i < _a.length; _i++) {\n    var definition = _a[_i];\n\n    if (definition.kind === 'FragmentDefinition') {\n      fragmentDefinitions[definition.name.value] = definition;\n    }\n  }\n\n  var visitors = {\n    SelectionSet: function (node) {\n      var selectionSetType = typeInfo ? typeInfo.getParentType() : null;\n      var selections = node.selections;\n      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);\n      selections = uniqueBy(selections, function (selection) {\n        return selection.alias ? selection.alias.value : selection.name.value;\n      });\n      return __assign(__assign({}, node), {\n        selections: selections\n      });\n    },\n    FragmentDefinition: function () {\n      return null;\n    }\n  };\n  return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);\n}","map":{"version":3,"sources":["../../src/utility/mergeAst.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { TypeInfo, getNamedType, visit, visitWithTypeInfo, } from 'graphql';\nexport function uniqueBy(array, iteratee) {\n    var FilteredMap = new Map();\n    var result = [];\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n        var item = array_1[_i];\n        if (item.kind === 'Field') {\n            var uniqueValue = iteratee(item);\n            var existing = FilteredMap.get(uniqueValue);\n            if (item.directives && item.directives.length) {\n                var itemClone = __assign({}, item);\n                result.push(itemClone);\n            }\n            else if (existing && existing.selectionSet && item.selectionSet) {\n                existing.selectionSet.selections = __spreadArrays(existing.selectionSet.selections, item.selectionSet.selections);\n            }\n            else if (!existing) {\n                var itemClone = __assign({}, item);\n                FilteredMap.set(uniqueValue, itemClone);\n                result.push(itemClone);\n            }\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\nexport function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {\n    var _a;\n    var selectionSetTypeName = selectionSetType\n        ? getNamedType(selectionSetType).name\n        : null;\n    var outputSelections = [];\n    var seenSpreads = [];\n    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n        var selection = selections_1[_i];\n        if (selection.kind === 'FragmentSpread') {\n            var fragmentName = selection.name.value;\n            if (!selection.directives || selection.directives.length === 0) {\n                if (seenSpreads.indexOf(fragmentName) >= 0) {\n                    continue;\n                }\n                else {\n                    seenSpreads.push(fragmentName);\n                }\n            }\n            var fragmentDefinition = fragmentDefinitions[selection.name.value];\n            if (fragmentDefinition) {\n                var typeCondition = fragmentDefinition.typeCondition, directives = fragmentDefinition.directives, selectionSet = fragmentDefinition.selectionSet;\n                selection = {\n                    kind: 'InlineFragment',\n                    typeCondition: typeCondition,\n                    directives: directives,\n                    selectionSet: selectionSet,\n                };\n            }\n        }\n        if (selection.kind === 'InlineFragment' &&\n            (!selection.directives || ((_a = selection.directives) === null || _a === void 0 ? void 0 : _a.length) === 0)) {\n            var fragmentTypeName = selection.typeCondition\n                ? selection.typeCondition.name.value\n                : null;\n            if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\n                outputSelections.push.apply(outputSelections, inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType));\n                continue;\n            }\n        }\n        outputSelections.push(selection);\n    }\n    return outputSelections;\n}\nexport default function mergeAST(documentAST, schema) {\n    var typeInfo = schema ? new TypeInfo(schema) : null;\n    var fragmentDefinitions = Object.create(null);\n    for (var _i = 0, _a = documentAST.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'FragmentDefinition') {\n            fragmentDefinitions[definition.name.value] = definition;\n        }\n    }\n    var visitors = {\n        SelectionSet: function (node) {\n            var selectionSetType = typeInfo ? typeInfo.getParentType() : null;\n            var selections = node.selections;\n            selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);\n            selections = uniqueBy(selections, function (selection) {\n                return selection.alias ? selection.alias.value : selection.name.value;\n            });\n            return __assign(__assign({}, node), { selections: selections });\n        },\n        FragmentDefinition: function () {\n            return null;\n        },\n    };\n    return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);\n}\n//# sourceMappingURL=mergeAst.js.map"]},"metadata":{},"sourceType":"module"}