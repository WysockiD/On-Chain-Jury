{"ast":null,"code":"\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphqlLanguageServiceParser = require(\"graphql-language-service-parser\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * The GraphQL mode is defined as a tokenizer along with a list of rules, each\n * of which is either a function or an array.\n *\n *   * Function: Provided a token and the stream, returns an expected next step.\n *   * Array: A list of steps to take in order.\n *\n * A step is either another rule, or a terminal description of a token. If it\n * is a rule, that rule is pushed onto the stack and the parsing continues from\n * that point.\n *\n * If it is a terminal description, the token is checked against it using a\n * `match` function. If the match is successful, the token is colored and the\n * rule is stepped forward. If the match is unsuccessful, the remainder of the\n * rule is skipped and the previous rule is advanced.\n *\n * This parsing algorithm allows for incremental online parsing within various\n * levels of the syntax tree and results in a structured `state` linked-list\n * which contains the relevant information to produce valuable typeaheads.\n */\n\n\n_codemirror.default.defineMode('graphql', config => {\n  const parser = (0, _graphqlLanguageServiceParser.onlineParser)({\n    eatWhitespace: stream => stream.eatWhile(_graphqlLanguageServiceParser.isIgnored),\n    lexRules: _graphqlLanguageServiceParser.LexRules,\n    parseRules: _graphqlLanguageServiceParser.ParseRules,\n    editorConfig: {\n      tabSize: config.tabSize\n    }\n  });\n  return {\n    config,\n    startState: parser.startState,\n    token: parser.token,\n    indent,\n    electricInput: /^\\s*[})\\]]/,\n    fold: 'brace',\n    lineComment: '#',\n    closeBrackets: {\n      pairs: '()[]{}\"\"',\n      explode: '()[]{}'\n    }\n  };\n});\n\nfunction indent(state, textAfter) {\n  const levels = state.levels; // If there is no stack of levels, use the current level.\n  // Otherwise, use the top level, pre-emptively dedenting for close braces.\n\n  const level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);\n  return level * this.config.indentUnit;\n}","map":{"version":3,"sources":["/home/dylan/Desktop/JuryDapp/node_modules/codemirror-graphql/mode.js"],"names":["_codemirror","_interopRequireDefault","require","_graphqlLanguageServiceParser","obj","__esModule","default","defineMode","config","parser","onlineParser","eatWhitespace","stream","eatWhile","isIgnored","lexRules","LexRules","parseRules","ParseRules","editorConfig","tabSize","startState","token","indent","electricInput","fold","lineComment","closeBrackets","pairs","explode","state","textAfter","levels","level","length","indentLevel","test","indentUnit"],"mappings":"AAAA;;AAEA,IAAIA,WAAW,GAAGC,sBAAsB,CAACC,OAAO,CAAC,YAAD,CAAR,CAAxC;;AAEA,IAAIC,6BAA6B,GAAGD,OAAO,CAAC,iCAAD,CAA3C;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,WAAW,CAACM,OAAZ,CAAoBC,UAApB,CAA+B,SAA/B,EAA0CC,MAAM,IAAI;AAClD,QAAMC,MAAM,GAAG,CAAC,GAAGN,6BAA6B,CAACO,YAAlC,EAAgD;AAC7DC,IAAAA,aAAa,EAAEC,MAAM,IAAIA,MAAM,CAACC,QAAP,CAAgBV,6BAA6B,CAACW,SAA9C,CADoC;AAE7DC,IAAAA,QAAQ,EAAEZ,6BAA6B,CAACa,QAFqB;AAG7DC,IAAAA,UAAU,EAAEd,6BAA6B,CAACe,UAHmB;AAI7DC,IAAAA,YAAY,EAAE;AACZC,MAAAA,OAAO,EAAEZ,MAAM,CAACY;AADJ;AAJ+C,GAAhD,CAAf;AAQA,SAAO;AACLZ,IAAAA,MADK;AAELa,IAAAA,UAAU,EAAEZ,MAAM,CAACY,UAFd;AAGLC,IAAAA,KAAK,EAAEb,MAAM,CAACa,KAHT;AAILC,IAAAA,MAJK;AAKLC,IAAAA,aAAa,EAAE,YALV;AAMLC,IAAAA,IAAI,EAAE,OAND;AAOLC,IAAAA,WAAW,EAAE,GAPR;AAQLC,IAAAA,aAAa,EAAE;AACbC,MAAAA,KAAK,EAAE,UADM;AAEbC,MAAAA,OAAO,EAAE;AAFI;AARV,GAAP;AAaD,CAtBD;;AAwBA,SAASN,MAAT,CAAgBO,KAAhB,EAAuBC,SAAvB,EAAkC;AAChC,QAAMC,MAAM,GAAGF,KAAK,CAACE,MAArB,CADgC,CACH;AAC7B;;AAEA,QAAMC,KAAK,GAAG,CAACD,MAAD,IAAWA,MAAM,CAACE,MAAP,KAAkB,CAA7B,GAAiCJ,KAAK,CAACK,WAAvC,GAAqDH,MAAM,CAACA,MAAM,CAACE,MAAP,GAAgB,CAAjB,CAAN,IAA6B,KAAKV,aAAL,CAAmBY,IAAnB,CAAwBL,SAAxB,IAAqC,CAArC,GAAyC,CAAtE,CAAnE;AACA,SAAOE,KAAK,GAAG,KAAKzB,MAAL,CAAY6B,UAA3B;AACD","sourcesContent":["\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphqlLanguageServiceParser = require(\"graphql-language-service-parser\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * The GraphQL mode is defined as a tokenizer along with a list of rules, each\n * of which is either a function or an array.\n *\n *   * Function: Provided a token and the stream, returns an expected next step.\n *   * Array: A list of steps to take in order.\n *\n * A step is either another rule, or a terminal description of a token. If it\n * is a rule, that rule is pushed onto the stack and the parsing continues from\n * that point.\n *\n * If it is a terminal description, the token is checked against it using a\n * `match` function. If the match is successful, the token is colored and the\n * rule is stepped forward. If the match is unsuccessful, the remainder of the\n * rule is skipped and the previous rule is advanced.\n *\n * This parsing algorithm allows for incremental online parsing within various\n * levels of the syntax tree and results in a structured `state` linked-list\n * which contains the relevant information to produce valuable typeaheads.\n */\n_codemirror.default.defineMode('graphql', config => {\n  const parser = (0, _graphqlLanguageServiceParser.onlineParser)({\n    eatWhitespace: stream => stream.eatWhile(_graphqlLanguageServiceParser.isIgnored),\n    lexRules: _graphqlLanguageServiceParser.LexRules,\n    parseRules: _graphqlLanguageServiceParser.ParseRules,\n    editorConfig: {\n      tabSize: config.tabSize\n    }\n  });\n  return {\n    config,\n    startState: parser.startState,\n    token: parser.token,\n    indent,\n    electricInput: /^\\s*[})\\]]/,\n    fold: 'brace',\n    lineComment: '#',\n    closeBrackets: {\n      pairs: '()[]{}\"\"',\n      explode: '()[]{}'\n    }\n  };\n});\n\nfunction indent(state, textAfter) {\n  const levels = state.levels; // If there is no stack of levels, use the current level.\n  // Otherwise, use the top level, pre-emptively dedenting for close braces.\n\n  const level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);\n  return level * this.config.indentUnit;\n}"]},"metadata":{},"sourceType":"script"}