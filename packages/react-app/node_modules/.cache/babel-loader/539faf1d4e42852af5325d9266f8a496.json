{"ast":null,"code":"import { useEffect, useRef } from \"react\"; // helper hook to call a function regularly in time intervals\n\nlet DEBUG = false;\nexport default function useOnBlock(provider, fn, args) {\n  const savedCallback = useRef(); // Remember the latest fn.\n\n  useEffect(() => {\n    savedCallback.current = fn;\n  }, [fn]); // Turn on the listener if we have a function & a provider\n\n  useEffect(() => {\n    if (fn && provider) {\n      const listener = blockNumber => {\n        if (DEBUG) console.log(blockNumber, fn, args, provider.listeners());\n\n        if (args && args.length > 0) {\n          savedCallback.current(...args);\n        } else {\n          savedCallback.current();\n        }\n      };\n\n      provider.on(\"block\", listener);\n      return () => {\n        provider.off(\"block\", listener);\n      };\n    }\n  }, [provider]);\n}","map":{"version":3,"sources":["/home/dylan/scaffold-eth/packages/react-app/src/hooks/OnBlock.js"],"names":["useEffect","useRef","DEBUG","useOnBlock","provider","fn","args","savedCallback","current","listener","blockNumber","console","log","listeners","length","on","off"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC,C,CAEA;;AACA,IAAIC,KAAK,GAAG,KAAZ;AAEA,eAAe,SAASC,UAAT,CAAoBC,QAApB,EAA8BC,EAA9B,EAAkCC,IAAlC,EAAwC;AACrD,QAAMC,aAAa,GAAGN,MAAM,EAA5B,CADqD,CAErD;;AACAD,EAAAA,SAAS,CAAC,MAAM;AACdO,IAAAA,aAAa,CAACC,OAAd,GAAwBH,EAAxB;AACD,GAFQ,EAEN,CAACA,EAAD,CAFM,CAAT,CAHqD,CAOrD;;AACAL,EAAAA,SAAS,CAAC,MAAM;AAChB,QAAIK,EAAE,IAAID,QAAV,EAAoB;AAElB,YAAMK,QAAQ,GAAIC,WAAD,IAAiB;AAChC,YAAIR,KAAJ,EAAWS,OAAO,CAACC,GAAR,CAAYF,WAAZ,EAAyBL,EAAzB,EAA6BC,IAA7B,EAAmCF,QAAQ,CAACS,SAAT,EAAnC;;AAEX,YAAIP,IAAI,IAAIA,IAAI,CAACQ,MAAL,GAAc,CAA1B,EAA6B;AAC3BP,UAAAA,aAAa,CAACC,OAAd,CAAsB,GAAGF,IAAzB;AACD,SAFD,MAEO;AACLC,UAAAA,aAAa,CAACC,OAAd;AACD;AAEF,OATD;;AAWAJ,MAAAA,QAAQ,CAACW,EAAT,CAAY,OAAZ,EAAqBN,QAArB;AAEA,aAAO,MAAM;AACTL,QAAAA,QAAQ,CAACY,GAAT,CAAa,OAAb,EAAsBP,QAAtB;AACH,OAFD;AAGH;AACA,GApBU,EAoBT,CAACL,QAAD,CApBS,CAAT;AAqBD","sourcesContent":["import { useEffect, useRef } from \"react\";\n\n// helper hook to call a function regularly in time intervals\nlet DEBUG = false\n\nexport default function useOnBlock(provider, fn, args) {\n  const savedCallback = useRef();\n  // Remember the latest fn.\n  useEffect(() => {\n    savedCallback.current = fn;\n  }, [fn]);\n\n  // Turn on the listener if we have a function & a provider\n  useEffect(() => {\n  if (fn && provider) {\n\n    const listener = (blockNumber) => {\n      if (DEBUG) console.log(blockNumber, fn, args, provider.listeners())\n\n      if (args && args.length > 0) {\n        savedCallback.current(...args);\n      } else {\n        savedCallback.current();\n      }\n\n    }\n\n    provider.on(\"block\", listener)\n\n    return () => {\n        provider.off(\"block\", listener)\n    }\n}\n},[provider])\n}\n"]},"metadata":{},"sourceType":"module"}