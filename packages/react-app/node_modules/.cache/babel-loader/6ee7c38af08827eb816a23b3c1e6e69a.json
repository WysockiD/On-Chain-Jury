{"ast":null,"code":"import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { parse, visit } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues } from './autocompleteUtils';\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  if (!state) {\n    return [];\n  }\n\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [{\n      label: 'query',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'mutation',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'subscription',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'fragment',\n      kind: CompletionItemKind.Function\n    }, {\n      label: '{',\n      kind: CompletionItemKind.Constructor\n    }]);\n  }\n\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, schema, kind);\n  }\n\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n\n    if (argDefs) {\n      return hintList(token, argDefs.map(argDef => {\n        var _a;\n\n        return {\n          label: argDef.name,\n          detail: String(argDef.type),\n          documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: CompletionItemKind.Variable\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map(field => {\n        var _a;\n\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: completionKind\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, kind);\n  }\n\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const queryVariables = [];\n    visit(parse(queryText, {\n      allowLegacySDLEmptyFields: true,\n      allowLegacySDLImplementsInterfaces: true\n    }), {\n      VariableDefinition(node) {\n        queryVariables.push(node);\n      }\n\n    });\n    return hintList(token, queryVariables.map(variableDef => ({\n      label: `$${variableDef.variable.name.value}`,\n      kind: CompletionItemKind.Variable,\n      detail: 'name' in variableDef.type ? variableDef.type.name.value : 'Variable'\n    })));\n  }\n\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n  }\n\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs);\n  }\n\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema, kind);\n  }\n\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema, kind);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFieldNames(token, typeInfo, schema, _kind) {\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n\n    if ('getFields' in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef);\n    }\n\n    if (parentType === schema.getQueryType()) {\n      fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n    }\n\n    return hintList(token, fields.map((field, index) => {\n      var _a;\n\n      return {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: field.isDeprecated,\n        isDeprecated: field.isDeprecated,\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field\n      };\n    }));\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo, _kind) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map(value => {\n      var _a;\n\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: value.isDeprecated,\n        isDeprecated: value.isDeprecated,\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember\n      };\n    }));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, [{\n      label: 'true',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not false.',\n      kind: CompletionItemKind.Variable\n    }, {\n      label: 'false',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not true.',\n      kind: CompletionItemKind.Variable\n    }]);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(type => {\n        type.getInterfaces().forEach(iface => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n\n  return hintList(token, possibleTypes.map(type => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || '',\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n\n  if (fragmentDefs) {\n    fragments.push(...fragmentDefs);\n  }\n\n  const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map(frag => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field\n  })));\n}\n\nexport function getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: 'Name',\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: 'Name',\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map(type => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter(directive => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map(directive => ({\n      label: directive.name,\n      documentation: directive.description || '',\n      kind: CompletionItemKind.Function\n    })));\n  }\n\n  return [];\n}\n\nexport function getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return 'BREAK';\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\nexport function runOnlineParser(queryText, callback) {\n  const lines = queryText.split('\\n');\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = '';\n  let stream = new CharacterStream('');\n\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n\n      if (code === 'BREAK') {\n        break;\n      }\n    }\n\n    callback(stream, state, style, i);\n\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\nexport function canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n\n  const kind = state.kind;\n  const locations = directive.locations;\n\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf('QUERY') !== -1;\n\n    case RuleKinds.MUTATION:\n      return locations.indexOf('MUTATION') !== -1;\n\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf('SUBSCRIPTION') !== -1;\n\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf('FIELD') !== -1;\n\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf('INLINE_FRAGMENT') !== -1;\n\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf('SCHEMA') !== -1;\n\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf('SCALAR') !== -1;\n\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf('OBJECT') !== -1;\n\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf('FIELD_DEFINITION') !== -1;\n\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf('INTERFACE') !== -1;\n\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf('UNION') !== -1;\n\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf('ENUM') !== -1;\n\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf('ENUM_VALUE') !== -1;\n\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf('INPUT_OBJECT') !== -1;\n\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = state.prevState && state.prevState.kind;\n\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n      }\n\n  }\n\n  return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  forEachState(tokenState, state => {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case 'ShortQuery':\n        type = schema.getQueryType();\n        break;\n\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n\n        break;\n\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD:\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n\n        break;\n\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n\n      case RuleKinds.ARGUMENTS:\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n\n            case RuleKinds.ALIASED_FIELD:\n              const name = state.prevState && state.prevState.name;\n\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n\n              argDefs = field.args;\n              break;\n\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n\n        break;\n\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n\n        inputType = argDef && argDef.type;\n        break;\n\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? find(enumType.getValues(), val => val.value === state.name) : null;\n        break;\n\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type\n  };\n}\n\nfunction find(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../src/getAutocompleteSuggestions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { parse, visit, } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds, } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues, } from './autocompleteUtils';\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n    if (!state) {\n        return [];\n    }\n    const kind = state.kind;\n    const step = state.step;\n    const typeInfo = getTypeInfo(schema, token.state);\n    if (kind === RuleKinds.DOCUMENT) {\n        return hintList(token, [\n            { label: 'query', kind: CompletionItemKind.Function },\n            { label: 'mutation', kind: CompletionItemKind.Function },\n            { label: 'subscription', kind: CompletionItemKind.Function },\n            { label: 'fragment', kind: CompletionItemKind.Function },\n            { label: '{', kind: CompletionItemKind.Constructor },\n        ]);\n    }\n    if (kind === RuleKinds.SELECTION_SET ||\n        kind === RuleKinds.FIELD ||\n        kind === RuleKinds.ALIASED_FIELD) {\n        return getSuggestionsForFieldNames(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.ARGUMENTS ||\n        (kind === RuleKinds.ARGUMENT && step === 0)) {\n        const argDefs = typeInfo.argDefs;\n        if (argDefs) {\n            return hintList(token, argDefs.map(argDef => {\n                var _a;\n                return ({\n                    label: argDef.name,\n                    detail: String(argDef.type),\n                    documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: CompletionItemKind.Variable,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.OBJECT_VALUE ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 0)) {\n        if (typeInfo.objectFieldDefs) {\n            const objectFields = objectValues(typeInfo.objectFieldDefs);\n            const completionKind = kind === RuleKinds.OBJECT_VALUE\n                ? CompletionItemKind.Value\n                : CompletionItemKind.Field;\n            return hintList(token, objectFields.map(field => {\n                var _a;\n                return ({\n                    label: field.name,\n                    detail: String(field.type),\n                    documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: completionKind,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.ENUM_VALUE ||\n        (kind === RuleKinds.LIST_VALUE && step === 1) ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 2) ||\n        (kind === RuleKinds.ARGUMENT && step === 2)) {\n        return getSuggestionsForInputValues(token, typeInfo, kind);\n    }\n    if (kind === RuleKinds.VARIABLE && step === 1) {\n        const queryVariables = [];\n        visit(parse(queryText, {\n            allowLegacySDLEmptyFields: true,\n            allowLegacySDLImplementsInterfaces: true,\n        }), {\n            VariableDefinition(node) {\n                queryVariables.push(node);\n            },\n        });\n        return hintList(token, queryVariables.map(variableDef => ({\n            label: `$${variableDef.variable.name.value}`,\n            kind: CompletionItemKind.Variable,\n            detail: 'name' in variableDef.type\n                ? variableDef.type.name.value\n                : 'Variable',\n        })));\n    }\n    if ((kind === RuleKinds.TYPE_CONDITION && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState != null &&\n            state.prevState.kind === RuleKinds.TYPE_CONDITION)) {\n        return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n        return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs);\n    }\n    if ((kind === RuleKinds.VARIABLE_DEFINITION && step === 2) ||\n        (kind === RuleKinds.LIST_TYPE && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState &&\n            (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION ||\n                state.prevState.kind === RuleKinds.LIST_TYPE ||\n                state.prevState.kind === RuleKinds.NON_NULL_TYPE))) {\n        return getSuggestionsForVariableDefinition(token, schema, kind);\n    }\n    if (kind === RuleKinds.DIRECTIVE) {\n        return getSuggestionsForDirective(token, state, schema, kind);\n    }\n    return [];\n}\nfunction getSuggestionsForFieldNames(token, typeInfo, schema, _kind) {\n    if (typeInfo.parentType) {\n        const parentType = typeInfo.parentType;\n        let fields = [];\n        if ('getFields' in parentType) {\n            fields = objectValues(parentType.getFields());\n        }\n        if (isCompositeType(parentType)) {\n            fields.push(TypeNameMetaFieldDef);\n        }\n        if (parentType === schema.getQueryType()) {\n            fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n        }\n        return hintList(token, fields.map((field, index) => {\n            var _a;\n            return ({\n                sortText: String(index) + field.name,\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: field.isDeprecated,\n                isDeprecated: field.isDeprecated,\n                deprecationReason: field.deprecationReason,\n                kind: CompletionItemKind.Field,\n            });\n        }));\n    }\n    return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, _kind) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    if (namedInputType instanceof GraphQLEnumType) {\n        const values = namedInputType.getValues();\n        return hintList(token, values.map((value) => {\n            var _a;\n            return ({\n                label: value.name,\n                detail: String(namedInputType),\n                documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: value.isDeprecated,\n                isDeprecated: value.isDeprecated,\n                deprecationReason: value.deprecationReason,\n                kind: CompletionItemKind.EnumMember,\n            });\n        }));\n    }\n    else if (namedInputType === GraphQLBoolean) {\n        return hintList(token, [\n            {\n                label: 'true',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not false.',\n                kind: CompletionItemKind.Variable,\n            },\n            {\n                label: 'false',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not true.',\n                kind: CompletionItemKind.Variable,\n            },\n        ]);\n    }\n    return [];\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n    let possibleTypes;\n    if (typeInfo.parentType) {\n        if (isAbstractType(typeInfo.parentType)) {\n            const abstractType = assertAbstractType(typeInfo.parentType);\n            const possibleObjTypes = schema.getPossibleTypes(abstractType);\n            const possibleIfaceMap = Object.create(null);\n            possibleObjTypes.forEach(type => {\n                type.getInterfaces().forEach(iface => {\n                    possibleIfaceMap[iface.name] = iface;\n                });\n            });\n            possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n        }\n        else {\n            possibleTypes = [typeInfo.parentType];\n        }\n    }\n    else {\n        const typeMap = schema.getTypeMap();\n        possibleTypes = objectValues(typeMap).filter(isCompositeType);\n    }\n    return hintList(token, possibleTypes.map((type) => {\n        const namedType = getNamedType(type);\n        return {\n            label: String(type),\n            documentation: (namedType && namedType.description) || '',\n            kind: CompletionItemKind.Field,\n        };\n    }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n    const typeMap = schema.getTypeMap();\n    const defState = getDefinitionState(token.state);\n    const fragments = getFragmentDefinitions(queryText);\n    if (fragmentDefs) {\n        fragments.push(...fragmentDefs);\n    }\n    const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] &&\n        !(defState &&\n            defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            defState.name === frag.name.value) &&\n        isCompositeType(typeInfo.parentType) &&\n        isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n        doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n    return hintList(token, relevantFrags.map(frag => ({\n        label: frag.name.value,\n        detail: String(typeMap[frag.typeCondition.name.value]),\n        documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n        kind: CompletionItemKind.Field,\n    })));\n}\nexport function getFragmentDefinitions(queryText) {\n    const fragmentDefs = [];\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            state.name &&\n            state.type) {\n            fragmentDefs.push({\n                kind: RuleKinds.FRAGMENT_DEFINITION,\n                name: {\n                    kind: 'Name',\n                    value: state.name,\n                },\n                selectionSet: {\n                    kind: RuleKinds.SELECTION_SET,\n                    selections: [],\n                },\n                typeCondition: {\n                    kind: RuleKinds.NAMED_TYPE,\n                    name: {\n                        kind: 'Name',\n                        value: state.type,\n                    },\n                },\n            });\n        }\n    });\n    return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n    const inputTypeMap = schema.getTypeMap();\n    const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n    return hintList(token, inputTypes.map((type) => ({\n        label: type.name,\n        documentation: type.description,\n        kind: CompletionItemKind.Variable,\n    })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n    if (state.prevState && state.prevState.kind) {\n        const directives = schema\n            .getDirectives()\n            .filter(directive => canUseDirective(state.prevState, directive));\n        return hintList(token, directives.map(directive => ({\n            label: directive.name,\n            documentation: directive.description || '',\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    return [];\n}\nexport function getTokenAtPosition(queryText, cursor) {\n    let styleAtCursor = null;\n    let stateAtCursor = null;\n    let stringAtCursor = null;\n    const token = runOnlineParser(queryText, (stream, state, style, index) => {\n        if (index === cursor.line) {\n            if (stream.getCurrentPosition() >= cursor.character) {\n                styleAtCursor = style;\n                stateAtCursor = Object.assign({}, state);\n                stringAtCursor = stream.current();\n                return 'BREAK';\n            }\n        }\n    });\n    return {\n        start: token.start,\n        end: token.end,\n        string: stringAtCursor || token.string,\n        state: stateAtCursor || token.state,\n        style: styleAtCursor || token.style,\n    };\n}\nexport function runOnlineParser(queryText, callback) {\n    const lines = queryText.split('\\n');\n    const parser = onlineParser();\n    let state = parser.startState();\n    let style = '';\n    let stream = new CharacterStream('');\n    for (let i = 0; i < lines.length; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            style = parser.token(stream, state);\n            const code = callback(stream, state, style, i);\n            if (code === 'BREAK') {\n                break;\n            }\n        }\n        callback(stream, state, style, i);\n        if (!state.kind) {\n            state = parser.startState();\n        }\n    }\n    return {\n        start: stream.getStartOfToken(),\n        end: stream.getCurrentPosition(),\n        string: stream.current(),\n        state,\n        style,\n    };\n}\nexport function canUseDirective(state, directive) {\n    if (!state || !state.kind) {\n        return false;\n    }\n    const kind = state.kind;\n    const locations = directive.locations;\n    switch (kind) {\n        case RuleKinds.QUERY:\n            return locations.indexOf('QUERY') !== -1;\n        case RuleKinds.MUTATION:\n            return locations.indexOf('MUTATION') !== -1;\n        case RuleKinds.SUBSCRIPTION:\n            return locations.indexOf('SUBSCRIPTION') !== -1;\n        case RuleKinds.FIELD:\n        case RuleKinds.ALIASED_FIELD:\n            return locations.indexOf('FIELD') !== -1;\n        case RuleKinds.FRAGMENT_DEFINITION:\n            return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n        case RuleKinds.FRAGMENT_SPREAD:\n            return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n        case RuleKinds.INLINE_FRAGMENT:\n            return locations.indexOf('INLINE_FRAGMENT') !== -1;\n        case RuleKinds.SCHEMA_DEF:\n            return locations.indexOf('SCHEMA') !== -1;\n        case RuleKinds.SCALAR_DEF:\n            return locations.indexOf('SCALAR') !== -1;\n        case RuleKinds.OBJECT_TYPE_DEF:\n            return locations.indexOf('OBJECT') !== -1;\n        case RuleKinds.FIELD_DEF:\n            return locations.indexOf('FIELD_DEFINITION') !== -1;\n        case RuleKinds.INTERFACE_DEF:\n            return locations.indexOf('INTERFACE') !== -1;\n        case RuleKinds.UNION_DEF:\n            return locations.indexOf('UNION') !== -1;\n        case RuleKinds.ENUM_DEF:\n            return locations.indexOf('ENUM') !== -1;\n        case RuleKinds.ENUM_VALUE:\n            return locations.indexOf('ENUM_VALUE') !== -1;\n        case RuleKinds.INPUT_DEF:\n            return locations.indexOf('INPUT_OBJECT') !== -1;\n        case RuleKinds.INPUT_VALUE_DEF:\n            const prevStateKind = state.prevState && state.prevState.kind;\n            switch (prevStateKind) {\n                case RuleKinds.ARGUMENTS_DEF:\n                    return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n                case RuleKinds.INPUT_DEF:\n                    return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n            }\n    }\n    return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n    let argDef;\n    let argDefs;\n    let directiveDef;\n    let enumValue;\n    let fieldDef;\n    let inputType;\n    let objectFieldDefs;\n    let parentType;\n    let type;\n    forEachState(tokenState, state => {\n        switch (state.kind) {\n            case RuleKinds.QUERY:\n            case 'ShortQuery':\n                type = schema.getQueryType();\n                break;\n            case RuleKinds.MUTATION:\n                type = schema.getMutationType();\n                break;\n            case RuleKinds.SUBSCRIPTION:\n                type = schema.getSubscriptionType();\n                break;\n            case RuleKinds.INLINE_FRAGMENT:\n            case RuleKinds.FRAGMENT_DEFINITION:\n                if (state.type) {\n                    type = schema.getType(state.type);\n                }\n                break;\n            case RuleKinds.FIELD:\n            case RuleKinds.ALIASED_FIELD:\n                if (!type || !state.name) {\n                    fieldDef = null;\n                }\n                else {\n                    fieldDef = parentType\n                        ? getFieldDef(schema, parentType, state.name)\n                        : null;\n                    type = fieldDef ? fieldDef.type : null;\n                }\n                break;\n            case RuleKinds.SELECTION_SET:\n                parentType = getNamedType(type);\n                break;\n            case RuleKinds.DIRECTIVE:\n                directiveDef = state.name ? schema.getDirective(state.name) : null;\n                break;\n            case RuleKinds.ARGUMENTS:\n                if (!state.prevState) {\n                    argDefs = null;\n                }\n                else {\n                    switch (state.prevState.kind) {\n                        case RuleKinds.FIELD:\n                            argDefs = fieldDef && fieldDef.args;\n                            break;\n                        case RuleKinds.DIRECTIVE:\n                            argDefs = directiveDef && directiveDef.args;\n                            break;\n                        case RuleKinds.ALIASED_FIELD:\n                            const name = state.prevState && state.prevState.name;\n                            if (!name) {\n                                argDefs = null;\n                                break;\n                            }\n                            const field = parentType\n                                ? getFieldDef(schema, parentType, name)\n                                : null;\n                            if (!field) {\n                                argDefs = null;\n                                break;\n                            }\n                            argDefs = field.args;\n                            break;\n                        default:\n                            argDefs = null;\n                            break;\n                    }\n                }\n                break;\n            case RuleKinds.ARGUMENT:\n                if (argDefs) {\n                    for (let i = 0; i < argDefs.length; i++) {\n                        if (argDefs[i].name === state.name) {\n                            argDef = argDefs[i];\n                            break;\n                        }\n                    }\n                }\n                inputType = argDef && argDef.type;\n                break;\n            case RuleKinds.ENUM_VALUE:\n                const enumType = getNamedType(inputType);\n                enumValue =\n                    enumType instanceof GraphQLEnumType\n                        ? find(enumType.getValues(), (val) => val.value === state.name)\n                        : null;\n                break;\n            case RuleKinds.LIST_VALUE:\n                const nullableType = getNullableType(inputType);\n                inputType =\n                    nullableType instanceof GraphQLList ? nullableType.ofType : null;\n                break;\n            case RuleKinds.OBJECT_VALUE:\n                const objectType = getNamedType(inputType);\n                objectFieldDefs =\n                    objectType instanceof GraphQLInputObjectType\n                        ? objectType.getFields()\n                        : null;\n                break;\n            case RuleKinds.OBJECT_FIELD:\n                const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n                inputType = objectField && objectField.type;\n                break;\n            case RuleKinds.NAMED_TYPE:\n                if (state.name) {\n                    type = schema.getType(state.name);\n                }\n                break;\n        }\n    });\n    return {\n        argDef,\n        argDefs,\n        directiveDef,\n        enumValue,\n        fieldDef,\n        inputType,\n        objectFieldDefs,\n        parentType,\n        type,\n    };\n}\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i])) {\n            return array[i];\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=getAutocompleteSuggestions.js.map"]},"metadata":{},"sourceType":"module"}