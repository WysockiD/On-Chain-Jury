{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { parse } from \"url\";\nimport { arrayify, concat } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getResponse(request) {\n  return new Promise((resolve, reject) => {\n    request.once(\"response\", resp => {\n      const response = {\n        statusCode: resp.statusCode,\n        statusMessage: resp.statusMessage,\n        headers: Object.keys(resp.headers).reduce((accum, name) => {\n          let value = resp.headers[name];\n\n          if (Array.isArray(value)) {\n            value = value.join(\", \");\n          }\n\n          accum[name] = value;\n          return accum;\n        }, {}),\n        body: null\n      }; //resp.setEncoding(\"utf8\");\n\n      resp.on(\"data\", chunk => {\n        if (response.body == null) {\n          response.body = new Uint8Array(0);\n        }\n\n        response.body = concat([response.body, chunk]);\n      });\n      resp.on(\"end\", () => {\n        if (response.headers[\"content-encoding\"] === \"gzip\") {\n          //const size = response.body.length;\n          response.body = arrayify(gunzipSync(response.body)); //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\n        }\n\n        resolve(response);\n      });\n      resp.on(\"error\", error => {\n        /* istanbul ignore next */\n        error.response = response;\n        reject(error);\n      });\n    });\n    request.on(\"error\", error => {\n      reject(error);\n    });\n  });\n} // The URL.parse uses null instead of the empty string\n\n\nfunction nonnull(value) {\n  if (value == null) {\n    return \"\";\n  }\n\n  return value;\n}\n\nexport function getUrl(href, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options == null) {\n      options = {};\n    } // @TODO: Once we drop support for node 8, we can pass the href\n    //        firectly into request and skip adding the components\n    //        to this request object\n\n\n    const url = parse(href);\n    const request = {\n      protocol: nonnull(url.protocol),\n      hostname: nonnull(url.hostname),\n      port: nonnull(url.port),\n      path: nonnull(url.pathname) + nonnull(url.search),\n      method: options.method || \"GET\",\n      headers: shallowCopy(options.headers || {})\n    };\n\n    if (options.allowGzip) {\n      request.headers[\"accept-encoding\"] = \"gzip\";\n    }\n\n    let req = null;\n\n    switch (nonnull(url.protocol)) {\n      case \"http:\":\n        req = http.request(request);\n        break;\n\n      case \"https:\":\n        req = https.request(request);\n        break;\n\n      default:\n        /* istanbul ignore next */\n        logger.throwError(`unsupported protocol ${url.protocol}`, Logger.errors.UNSUPPORTED_OPERATION, {\n          protocol: url.protocol,\n          operation: \"request\"\n        });\n    }\n\n    if (options.body) {\n      req.write(Buffer.from(options.body));\n    }\n\n    req.end();\n    const response = yield getResponse(req);\n    return response;\n  });\n}","map":{"version":3,"sources":["../src.ts/geturl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { parse } from \"url\";\nimport { arrayify, concat } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction getResponse(request) {\n    return new Promise((resolve, reject) => {\n        request.once(\"response\", (resp) => {\n            const response = {\n                statusCode: resp.statusCode,\n                statusMessage: resp.statusMessage,\n                headers: Object.keys(resp.headers).reduce((accum, name) => {\n                    let value = resp.headers[name];\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {}),\n                body: null\n            };\n            //resp.setEncoding(\"utf8\");\n            resp.on(\"data\", (chunk) => {\n                if (response.body == null) {\n                    response.body = new Uint8Array(0);\n                }\n                response.body = concat([response.body, chunk]);\n            });\n            resp.on(\"end\", () => {\n                if (response.headers[\"content-encoding\"] === \"gzip\") {\n                    //const size = response.body.length;\n                    response.body = arrayify(gunzipSync(response.body));\n                    //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\n                }\n                resolve(response);\n            });\n            resp.on(\"error\", (error) => {\n                /* istanbul ignore next */\n                error.response = response;\n                reject(error);\n            });\n        });\n        request.on(\"error\", (error) => { reject(error); });\n    });\n}\n// The URL.parse uses null instead of the empty string\nfunction nonnull(value) {\n    if (value == null) {\n        return \"\";\n    }\n    return value;\n}\nexport function getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        // @TODO: Once we drop support for node 8, we can pass the href\n        //        firectly into request and skip adding the components\n        //        to this request object\n        const url = parse(href);\n        const request = {\n            protocol: nonnull(url.protocol),\n            hostname: nonnull(url.hostname),\n            port: nonnull(url.port),\n            path: (nonnull(url.pathname) + nonnull(url.search)),\n            method: (options.method || \"GET\"),\n            headers: shallowCopy(options.headers || {}),\n        };\n        if (options.allowGzip) {\n            request.headers[\"accept-encoding\"] = \"gzip\";\n        }\n        let req = null;\n        switch (nonnull(url.protocol)) {\n            case \"http:\":\n                req = http.request(request);\n                break;\n            case \"https:\":\n                req = https.request(request);\n                break;\n            default:\n                /* istanbul ignore next */\n                logger.throwError(`unsupported protocol ${url.protocol}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    protocol: url.protocol,\n                    operation: \"request\"\n                });\n        }\n        if (options.body) {\n            req.write(Buffer.from(options.body));\n        }\n        req.end();\n        const response = yield getResponse(req);\n        return response;\n    });\n}\n//# sourceMappingURL=geturl.js.map"]},"metadata":{},"sourceType":"module"}