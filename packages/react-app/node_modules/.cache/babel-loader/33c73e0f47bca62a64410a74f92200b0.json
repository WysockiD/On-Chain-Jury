{"ast":null,"code":"\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphqlLanguageServiceInterface = require(\"graphql-language-service-interface\");\n\nvar _graphql = require(\"graphql\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n *\n */\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - schema: GraphQLSchema provides the hinter with positionally relevant info\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\n\n\n_codemirror.default.registerHelper('hint', 'graphql', (editor, options) => {\n  const schema = options.schema;\n\n  if (!schema) {\n    return;\n  }\n\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), token);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const results = {\n    list: rawResults.map(item => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: {\n      line: cur.line,\n      column: tokenStart\n    },\n    to: {\n      line: cur.line,\n      column: token.end\n    }\n  };\n\n  if (results && results.list && results.list.length > 0) {\n    results.from = _codemirror.default.Pos(results.from.line, results.from.column);\n    results.to = _codemirror.default.Pos(results.to.line, results.to.column);\n\n    _codemirror.default.signal(editor, 'hasCompletion', editor, results, token);\n  }\n\n  return results;\n});\n/**\n * Given GraphQLSchema, queryText, and context of the current position within\n * the source text, provide a list of typeahead entries.\n */\n\n\nfunction getAutocompleteSuggestions(schema, queryText, token) {\n  const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state; // relieve flow errors by checking if `state` exists\n\n  if (!state) {\n    return [];\n  }\n\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = (0, _graphqlLanguageServiceInterface.getTypeInfo)(schema, token.state); // Definition kinds\n\n  if (kind === 'Document') {\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, [{\n      label: 'query'\n    }, {\n      label: 'mutation'\n    }, {\n      label: 'subscription'\n    }, {\n      label: 'fragment'\n    }, {\n      label: '{'\n    }]);\n  } // Field names\n\n\n  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {\n    return getSuggestionsForFieldNames(token, typeInfo, schema);\n  } // Argument names\n\n\n  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {\n    const argDefs = typeInfo.argDefs;\n\n    if (argDefs) {\n      return (0, _graphqlLanguageServiceInterface.hintList)(token, argDefs.map(argDef => {\n        var _argDef$description;\n\n        return {\n          label: argDef.name,\n          type: argDef.type,\n          documentation: (_argDef$description = argDef.description) !== null && _argDef$description !== void 0 ? _argDef$description : undefined\n        };\n      }));\n    }\n  } // Input Object fields\n\n\n  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = (0, _graphqlLanguageServiceInterface.objectValues)(typeInfo.objectFieldDefs);\n      return (0, _graphqlLanguageServiceInterface.hintList)(token, objectFields.map(field => {\n        var _field$description;\n\n        return {\n          label: field.name,\n          type: field.type,\n          documentation: (_field$description = field.description) !== null && _field$description !== void 0 ? _field$description : undefined\n        };\n      }));\n    }\n  } // Input values: Enum and Boolean\n\n\n  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo);\n  } // Fragment type conditions\n\n\n  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState != null && state.prevState.kind === 'TypeCondition') {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  } // Fragment spread names\n\n\n  if (kind === 'FragmentSpread' && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText);\n  } // Variable definition types\n\n\n  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && state.prevState && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  } // Directive names\n\n\n  if (kind === 'Directive') {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n\n  return [];\n} // Helper functions to get suggestions for each kinds\n\n\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    const fields = (0, _graphql.isObjectType)(parentType) && 'getFields' in parentType ? (0, _graphqlLanguageServiceInterface.objectValues)(parentType.getFields()) : [];\n\n    if ((0, _graphql.isCompositeType)(parentType)) {\n      fields.push(_graphql.TypeNameMetaFieldDef);\n    }\n\n    if (parentType === schema.getQueryType()) {\n      fields.push(_graphql.SchemaMetaFieldDef, _graphql.TypeMetaFieldDef);\n    }\n\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, fields.map(field => {\n      var _field$description2;\n\n      return {\n        label: field.name,\n        type: field.type,\n        documentation: (_field$description2 = field.description) !== null && _field$description2 !== void 0 ? _field$description2 : undefined,\n        isDeprecated: field.isDeprecated,\n        deprecationReason: field.deprecationReason\n      };\n    }));\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo) {\n  const namedInputType = (0, _graphql.getNamedType)(typeInfo.inputType);\n\n  if (namedInputType instanceof _graphql.GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, values.map(value => {\n      var _value$description;\n\n      return {\n        label: value.name,\n        type: namedInputType,\n        documentation: (_value$description = value.description) !== null && _value$description !== void 0 ? _value$description : undefined,\n        isDeprecated: value.isDeprecated,\n        deprecationReason: value.deprecationReason\n      };\n    }));\n  } else if (namedInputType === _graphql.GraphQLBoolean) {\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, [{\n      label: 'true',\n      type: _graphql.GraphQLBoolean,\n      documentation: 'Not false.'\n    }, {\n      label: 'false',\n      type: _graphql.GraphQLBoolean,\n      documentation: 'Not true.'\n    }]);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema) {\n  let possibleTypes;\n\n  if (typeInfo.parentType) {\n    if ((0, _graphql.isAbstractType)(typeInfo.parentType)) {\n      const abstractType = (0, _graphql.assertAbstractType)(typeInfo.parentType); // Collect both the possible Object types as well as the interfaces\n      // they implement.\n\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(type => {\n        type.getInterfaces().forEach(iface => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat((0, _graphqlLanguageServiceInterface.objectValues)(possibleIfaceMap));\n    } else {\n      // The parent type is a non-abstract Object type, so the only possible\n      // type that can be used is that same type.\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = (0, _graphqlLanguageServiceInterface.objectValues)(typeMap).filter(_graphql.isCompositeType);\n  }\n\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, possibleTypes.map(type => {\n    const namedType = (0, _graphql.getNamedType)(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || ''\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText) {\n  const typeMap = schema.getTypeMap();\n  const defState = (0, _graphqlLanguageServiceInterface.getDefinitionState)(token.state);\n  const fragments = (0, _graphqlLanguageServiceInterface.getFragmentDefinitions)(queryText); // Filter down to only the fragments which may exist here.\n\n  const relevantFrags = fragments.filter(frag => // Only include fragments with known types.\n  typeMap[frag.typeCondition.name.value] && // Only include fragments which are not cyclic.\n  !(defState && defState.kind === 'FragmentDefinition' && defState.name === frag.name.value) && // Only include fragments which could possibly be spread here.\n  (0, _graphql.isCompositeType)(typeInfo.parentType) && (0, _graphql.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, _graphql.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, relevantFrags.map(frag => ({\n    label: frag.name.value,\n    type: typeMap[frag.typeCondition.name.value],\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`\n  })));\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = (0, _graphqlLanguageServiceInterface.objectValues)(inputTypeMap).filter(_graphql.isInputType);\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, inputTypes.map(type => ({\n    label: type.name,\n    documentation: type.description\n  })));\n}\n\nfunction getSuggestionsForDirective(token, state, schema) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter(directive => (0, _graphqlLanguageServiceInterface.canUseDirective)(state.prevState, directive));\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, directives.map(directive => ({\n      label: directive.name,\n      documentation: directive.description || ''\n    })));\n  }\n\n  return [];\n}","map":{"version":3,"sources":["/home/dylan/Desktop/JuryDapp/node_modules/codemirror-graphql/hint.js"],"names":["_codemirror","_interopRequireDefault","require","_graphqlLanguageServiceInterface","_graphql","obj","__esModule","default","registerHelper","editor","options","schema","cur","getCursor","token","getTokenAt","rawResults","getAutocompleteSuggestions","getValue","tokenStart","type","test","string","start","end","results","list","map","item","text","label","description","documentation","isDeprecated","deprecationReason","from","line","column","to","length","Pos","signal","queryText","state","kind","prevState","step","typeInfo","getTypeInfo","hintList","getSuggestionsForFieldNames","argDefs","argDef","_argDef$description","name","undefined","objectFieldDefs","objectFields","objectValues","field","_field$description","getSuggestionsForInputValues","getSuggestionsForFragmentTypeConditions","getSuggestionsForFragmentSpread","getSuggestionsForVariableDefinition","getSuggestionsForDirective","parentType","fields","isObjectType","getFields","isCompositeType","push","TypeNameMetaFieldDef","getQueryType","SchemaMetaFieldDef","TypeMetaFieldDef","_field$description2","namedInputType","getNamedType","inputType","GraphQLEnumType","values","getValues","value","_value$description","GraphQLBoolean","possibleTypes","isAbstractType","abstractType","assertAbstractType","possibleObjTypes","getPossibleTypes","possibleIfaceMap","Object","create","forEach","getInterfaces","iface","concat","typeMap","getTypeMap","filter","namedType","String","defState","getDefinitionState","fragments","getFragmentDefinitions","relevantFrags","frag","typeCondition","doTypesOverlap","inputTypeMap","inputTypes","isInputType","directives","getDirectives","directive","canUseDirective"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _codemirror = _interopRequireDefault(require(\"codemirror\"));\n\nvar _graphqlLanguageServiceInterface = require(\"graphql-language-service-interface\");\n\nvar _graphql = require(\"graphql\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n *\n */\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - schema: GraphQLSchema provides the hinter with positionally relevant info\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\n_codemirror.default.registerHelper('hint', 'graphql', (editor, options) => {\n  const schema = options.schema;\n\n  if (!schema) {\n    return;\n  }\n\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), token);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const results = {\n    list: rawResults.map(item => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: {\n      line: cur.line,\n      column: tokenStart\n    },\n    to: {\n      line: cur.line,\n      column: token.end\n    }\n  };\n\n  if (results && results.list && results.list.length > 0) {\n    results.from = _codemirror.default.Pos(results.from.line, results.from.column);\n    results.to = _codemirror.default.Pos(results.to.line, results.to.column);\n\n    _codemirror.default.signal(editor, 'hasCompletion', editor, results, token);\n  }\n\n  return results;\n});\n/**\n * Given GraphQLSchema, queryText, and context of the current position within\n * the source text, provide a list of typeahead entries.\n */\n\n\nfunction getAutocompleteSuggestions(schema, queryText, token) {\n  const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state; // relieve flow errors by checking if `state` exists\n\n  if (!state) {\n    return [];\n  }\n\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = (0, _graphqlLanguageServiceInterface.getTypeInfo)(schema, token.state); // Definition kinds\n\n  if (kind === 'Document') {\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, [{\n      label: 'query'\n    }, {\n      label: 'mutation'\n    }, {\n      label: 'subscription'\n    }, {\n      label: 'fragment'\n    }, {\n      label: '{'\n    }]);\n  } // Field names\n\n\n  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {\n    return getSuggestionsForFieldNames(token, typeInfo, schema);\n  } // Argument names\n\n\n  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {\n    const argDefs = typeInfo.argDefs;\n\n    if (argDefs) {\n      return (0, _graphqlLanguageServiceInterface.hintList)(token, argDefs.map(argDef => {\n        var _argDef$description;\n\n        return {\n          label: argDef.name,\n          type: argDef.type,\n          documentation: (_argDef$description = argDef.description) !== null && _argDef$description !== void 0 ? _argDef$description : undefined\n        };\n      }));\n    }\n  } // Input Object fields\n\n\n  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = (0, _graphqlLanguageServiceInterface.objectValues)(typeInfo.objectFieldDefs);\n      return (0, _graphqlLanguageServiceInterface.hintList)(token, objectFields.map(field => {\n        var _field$description;\n\n        return {\n          label: field.name,\n          type: field.type,\n          documentation: (_field$description = field.description) !== null && _field$description !== void 0 ? _field$description : undefined\n        };\n      }));\n    }\n  } // Input values: Enum and Boolean\n\n\n  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo);\n  } // Fragment type conditions\n\n\n  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState != null && state.prevState.kind === 'TypeCondition') {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  } // Fragment spread names\n\n\n  if (kind === 'FragmentSpread' && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText);\n  } // Variable definition types\n\n\n  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && state.prevState && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  } // Directive names\n\n\n  if (kind === 'Directive') {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n\n  return [];\n} // Helper functions to get suggestions for each kinds\n\n\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    const fields = (0, _graphql.isObjectType)(parentType) && 'getFields' in parentType ? (0, _graphqlLanguageServiceInterface.objectValues)(parentType.getFields()) : [];\n\n    if ((0, _graphql.isCompositeType)(parentType)) {\n      fields.push(_graphql.TypeNameMetaFieldDef);\n    }\n\n    if (parentType === schema.getQueryType()) {\n      fields.push(_graphql.SchemaMetaFieldDef, _graphql.TypeMetaFieldDef);\n    }\n\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, fields.map(field => {\n      var _field$description2;\n\n      return {\n        label: field.name,\n        type: field.type,\n        documentation: (_field$description2 = field.description) !== null && _field$description2 !== void 0 ? _field$description2 : undefined,\n        isDeprecated: field.isDeprecated,\n        deprecationReason: field.deprecationReason\n      };\n    }));\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo) {\n  const namedInputType = (0, _graphql.getNamedType)(typeInfo.inputType);\n\n  if (namedInputType instanceof _graphql.GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, values.map(value => {\n      var _value$description;\n\n      return {\n        label: value.name,\n        type: namedInputType,\n        documentation: (_value$description = value.description) !== null && _value$description !== void 0 ? _value$description : undefined,\n        isDeprecated: value.isDeprecated,\n        deprecationReason: value.deprecationReason\n      };\n    }));\n  } else if (namedInputType === _graphql.GraphQLBoolean) {\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, [{\n      label: 'true',\n      type: _graphql.GraphQLBoolean,\n      documentation: 'Not false.'\n    }, {\n      label: 'false',\n      type: _graphql.GraphQLBoolean,\n      documentation: 'Not true.'\n    }]);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema) {\n  let possibleTypes;\n\n  if (typeInfo.parentType) {\n    if ((0, _graphql.isAbstractType)(typeInfo.parentType)) {\n      const abstractType = (0, _graphql.assertAbstractType)(typeInfo.parentType); // Collect both the possible Object types as well as the interfaces\n      // they implement.\n\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(type => {\n        type.getInterfaces().forEach(iface => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat((0, _graphqlLanguageServiceInterface.objectValues)(possibleIfaceMap));\n    } else {\n      // The parent type is a non-abstract Object type, so the only possible\n      // type that can be used is that same type.\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = (0, _graphqlLanguageServiceInterface.objectValues)(typeMap).filter(_graphql.isCompositeType);\n  }\n\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, possibleTypes.map(type => {\n    const namedType = (0, _graphql.getNamedType)(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || ''\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText) {\n  const typeMap = schema.getTypeMap();\n  const defState = (0, _graphqlLanguageServiceInterface.getDefinitionState)(token.state);\n  const fragments = (0, _graphqlLanguageServiceInterface.getFragmentDefinitions)(queryText); // Filter down to only the fragments which may exist here.\n\n  const relevantFrags = fragments.filter(frag => // Only include fragments with known types.\n  typeMap[frag.typeCondition.name.value] && // Only include fragments which are not cyclic.\n  !(defState && defState.kind === 'FragmentDefinition' && defState.name === frag.name.value) && // Only include fragments which could possibly be spread here.\n  (0, _graphql.isCompositeType)(typeInfo.parentType) && (0, _graphql.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, _graphql.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, relevantFrags.map(frag => ({\n    label: frag.name.value,\n    type: typeMap[frag.typeCondition.name.value],\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`\n  })));\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = (0, _graphqlLanguageServiceInterface.objectValues)(inputTypeMap).filter(_graphql.isInputType);\n  return (0, _graphqlLanguageServiceInterface.hintList)(token, inputTypes.map(type => ({\n    label: type.name,\n    documentation: type.description\n  })));\n}\n\nfunction getSuggestionsForDirective(token, state, schema) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter(directive => (0, _graphqlLanguageServiceInterface.canUseDirective)(state.prevState, directive));\n    return (0, _graphqlLanguageServiceInterface.hintList)(token, directives.map(directive => ({\n      label: directive.name,\n      documentation: directive.description || ''\n    })));\n  }\n\n  return [];\n}"]},"metadata":{},"sourceType":"script"}