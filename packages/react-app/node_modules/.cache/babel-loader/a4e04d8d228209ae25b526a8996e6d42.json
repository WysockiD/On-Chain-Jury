{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(GraphQLSpecifiedByDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"sources":["/home/dylan/scaffold-eth/node_modules/graphql/utilities/buildASTSchema.mjs"],"names":["devAssert","Kind","parse","assertValidSDL","GraphQLSchema","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLSpecifiedByDirective","extendSchemaImpl","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","emptySchemaConfig","description","undefined","types","directives","extensions","extensionASTNodes","config","astNode","_i2","_config$types2","length","type","name","query","mutation","subscription","some","directive","push","buildSchema","source","document","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","commentDescriptions"],"mappings":"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","sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(GraphQLSpecifiedByDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"]},"metadata":{},"sourceType":"module"}