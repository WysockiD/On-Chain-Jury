{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = jsonParse;\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This JSON parser simply walks the input, generating an AST. Use this in lieu\n * of JSON.parse if you need character offset parse errors and an AST parse tree\n * with location information.\n *\n * If an error is encountered, a SyntaxError will be thrown, with properties:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\n\nfunction jsonParse(str) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  const ast = parseObj();\n  expect('EOF');\n  return ast;\n}\n\nlet string;\nlet strLen;\nlet start;\nlet end;\nlet lastEnd;\nlet code;\nlet kind;\n\nfunction parseObj() {\n  const nodeStart = start;\n  const members = [];\n  expect('{');\n\n  if (!skip('}')) {\n    do {\n      members.push(parseMember());\n    } while (skip(','));\n\n    expect('}');\n  }\n\n  return {\n    kind: 'Object',\n    start: nodeStart,\n    end: lastEnd,\n    members\n  };\n}\n\nfunction parseMember() {\n  const nodeStart = start;\n  const key = kind === 'String' ? curToken() : null;\n  expect('String');\n  expect(':');\n  const value = parseVal();\n  return {\n    kind: 'Member',\n    start: nodeStart,\n    end: lastEnd,\n    key,\n    value\n  };\n}\n\nfunction parseArr() {\n  const nodeStart = start;\n  const values = [];\n  expect('[');\n\n  if (!skip(']')) {\n    do {\n      values.push(parseVal());\n    } while (skip(','));\n\n    expect(']');\n  }\n\n  return {\n    kind: 'Array',\n    start: nodeStart,\n    end: lastEnd,\n    values\n  };\n}\n\nfunction parseVal() {\n  switch (kind) {\n    case '[':\n      return parseArr();\n\n    case '{':\n      return parseObj();\n\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n      const token = curToken();\n      lex();\n      return token;\n  }\n\n  return expect('Value');\n}\n\nfunction curToken() {\n  return {\n    kind,\n    start,\n    end,\n    value: JSON.parse(string.slice(start, end))\n  };\n}\n\nfunction expect(str) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n\n  let found;\n\n  if (kind === 'EOF') {\n    found = '[end of file]';\n  } else if (end - start > 1) {\n    found = '`' + string.slice(start, end) + '`';\n  } else {\n    const match = string.slice(start).match(/^.+?\\b/);\n    found = '`' + (match ? match[0] : string[start]) + '`';\n  }\n\n  throw syntaxError(`Expected ${str} but found ${found}.`);\n}\n\nfunction syntaxError(message) {\n  return {\n    message,\n    start,\n    end\n  };\n}\n\nfunction skip(k) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n}\n\nfunction lex() {\n  lastEnd = end;\n\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -, 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = 'Number';\n      return readNumber();\n    // f\n\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n\n      end += 4;\n      ch();\n      kind = 'Boolean';\n      return;\n    // n\n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Null';\n      return;\n    // t\n\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Boolean';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n\n  while (code !== 34 && code > 31) {\n    if (code === 92) {\n      // \\\n      ch();\n\n      switch (code) {\n        case 34: // \"\n\n        case 47: // /\n\n        case 92: // \\\n\n        case 98: // b\n\n        case 102: // f\n\n        case 110: // n\n\n        case 114: // r\n\n        case 116:\n          // t\n          ch();\n          break;\n\n        case 117:\n          // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    } else {\n      ch();\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 70 || // A-F\n  code >= 97 && code <= 102 // a-f\n  ) {\n      return ch();\n    }\n\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    ch();\n\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n\n}","map":{"version":3,"sources":["/home/dylan/scaffold-eth/node_modules/codemirror-graphql/utils/jsonParse.js"],"names":["Object","defineProperty","exports","value","default","jsonParse","str","string","strLen","length","start","end","lastEnd","ch","lex","ast","parseObj","expect","code","kind","nodeStart","members","skip","push","parseMember","key","curToken","parseVal","parseArr","values","token","JSON","parse","slice","found","match","syntaxError","message","k","charCodeAt","readString","readNumber","readHex","readDigits"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,SAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,SAAT,CAAmBC,GAAnB,EAAwB;AACtBC,EAAAA,MAAM,GAAGD,GAAT;AACAE,EAAAA,MAAM,GAAGF,GAAG,CAACG,MAAb;AACAC,EAAAA,KAAK,GAAGC,GAAG,GAAGC,OAAO,GAAG,CAAC,CAAzB;AACAC,EAAAA,EAAE;AACFC,EAAAA,GAAG;AACH,QAAMC,GAAG,GAAGC,QAAQ,EAApB;AACAC,EAAAA,MAAM,CAAC,KAAD,CAAN;AACA,SAAOF,GAAP;AACD;;AAED,IAAIR,MAAJ;AACA,IAAIC,MAAJ;AACA,IAAIE,KAAJ;AACA,IAAIC,GAAJ;AACA,IAAIC,OAAJ;AACA,IAAIM,IAAJ;AACA,IAAIC,IAAJ;;AAEA,SAASH,QAAT,GAAoB;AAClB,QAAMI,SAAS,GAAGV,KAAlB;AACA,QAAMW,OAAO,GAAG,EAAhB;AACAJ,EAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,MAAI,CAACK,IAAI,CAAC,GAAD,CAAT,EAAgB;AACd,OAAG;AACDD,MAAAA,OAAO,CAACE,IAAR,CAAaC,WAAW,EAAxB;AACD,KAFD,QAESF,IAAI,CAAC,GAAD,CAFb;;AAIAL,IAAAA,MAAM,CAAC,GAAD,CAAN;AACD;;AAED,SAAO;AACLE,IAAAA,IAAI,EAAE,QADD;AAELT,IAAAA,KAAK,EAAEU,SAFF;AAGLT,IAAAA,GAAG,EAAEC,OAHA;AAILS,IAAAA;AAJK,GAAP;AAMD;;AAED,SAASG,WAAT,GAAuB;AACrB,QAAMJ,SAAS,GAAGV,KAAlB;AACA,QAAMe,GAAG,GAAGN,IAAI,KAAK,QAAT,GAAoBO,QAAQ,EAA5B,GAAiC,IAA7C;AACAT,EAAAA,MAAM,CAAC,QAAD,CAAN;AACAA,EAAAA,MAAM,CAAC,GAAD,CAAN;AACA,QAAMd,KAAK,GAAGwB,QAAQ,EAAtB;AACA,SAAO;AACLR,IAAAA,IAAI,EAAE,QADD;AAELT,IAAAA,KAAK,EAAEU,SAFF;AAGLT,IAAAA,GAAG,EAAEC,OAHA;AAILa,IAAAA,GAJK;AAKLtB,IAAAA;AALK,GAAP;AAOD;;AAED,SAASyB,QAAT,GAAoB;AAClB,QAAMR,SAAS,GAAGV,KAAlB;AACA,QAAMmB,MAAM,GAAG,EAAf;AACAZ,EAAAA,MAAM,CAAC,GAAD,CAAN;;AAEA,MAAI,CAACK,IAAI,CAAC,GAAD,CAAT,EAAgB;AACd,OAAG;AACDO,MAAAA,MAAM,CAACN,IAAP,CAAYI,QAAQ,EAApB;AACD,KAFD,QAESL,IAAI,CAAC,GAAD,CAFb;;AAIAL,IAAAA,MAAM,CAAC,GAAD,CAAN;AACD;;AAED,SAAO;AACLE,IAAAA,IAAI,EAAE,OADD;AAELT,IAAAA,KAAK,EAAEU,SAFF;AAGLT,IAAAA,GAAG,EAAEC,OAHA;AAILiB,IAAAA;AAJK,GAAP;AAMD;;AAED,SAASF,QAAT,GAAoB;AAClB,UAAQR,IAAR;AACE,SAAK,GAAL;AACE,aAAOS,QAAQ,EAAf;;AAEF,SAAK,GAAL;AACE,aAAOZ,QAAQ,EAAf;;AAEF,SAAK,QAAL;AACA,SAAK,QAAL;AACA,SAAK,SAAL;AACA,SAAK,MAAL;AACE,YAAMc,KAAK,GAAGJ,QAAQ,EAAtB;AACAZ,MAAAA,GAAG;AACH,aAAOgB,KAAP;AAbJ;;AAgBA,SAAOb,MAAM,CAAC,OAAD,CAAb;AACD;;AAED,SAASS,QAAT,GAAoB;AAClB,SAAO;AACLP,IAAAA,IADK;AAELT,IAAAA,KAFK;AAGLC,IAAAA,GAHK;AAILR,IAAAA,KAAK,EAAE4B,IAAI,CAACC,KAAL,CAAWzB,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoBC,GAApB,CAAX;AAJF,GAAP;AAMD;;AAED,SAASM,MAAT,CAAgBX,GAAhB,EAAqB;AACnB,MAAIa,IAAI,KAAKb,GAAb,EAAkB;AAChBQ,IAAAA,GAAG;AACH;AACD;;AAED,MAAIoB,KAAJ;;AAEA,MAAIf,IAAI,KAAK,KAAb,EAAoB;AAClBe,IAAAA,KAAK,GAAG,eAAR;AACD,GAFD,MAEO,IAAIvB,GAAG,GAAGD,KAAN,GAAc,CAAlB,EAAqB;AAC1BwB,IAAAA,KAAK,GAAG,MAAM3B,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoBC,GAApB,CAAN,GAAiC,GAAzC;AACD,GAFM,MAEA;AACL,UAAMwB,KAAK,GAAG5B,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoByB,KAApB,CAA0B,QAA1B,CAAd;AACAD,IAAAA,KAAK,GAAG,OAAOC,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc5B,MAAM,CAACG,KAAD,CAAhC,IAA2C,GAAnD;AACD;;AAED,QAAM0B,WAAW,CAAE,YAAW9B,GAAI,cAAa4B,KAAM,GAApC,CAAjB;AACD;;AAED,SAASE,WAAT,CAAqBC,OAArB,EAA8B;AAC5B,SAAO;AACLA,IAAAA,OADK;AAEL3B,IAAAA,KAFK;AAGLC,IAAAA;AAHK,GAAP;AAKD;;AAED,SAASW,IAAT,CAAcgB,CAAd,EAAiB;AACf,MAAInB,IAAI,KAAKmB,CAAb,EAAgB;AACdxB,IAAAA,GAAG;AACH,WAAO,IAAP;AACD;AACF;;AAED,SAASD,EAAT,GAAc;AACZ,MAAIF,GAAG,GAAGH,MAAV,EAAkB;AAChBG,IAAAA,GAAG;AACHO,IAAAA,IAAI,GAAGP,GAAG,KAAKH,MAAR,GAAiB,CAAjB,GAAqBD,MAAM,CAACgC,UAAP,CAAkB5B,GAAlB,CAA5B;AACD;AACF;;AAED,SAASG,GAAT,GAAe;AACbF,EAAAA,OAAO,GAAGD,GAAV;;AAEA,SAAOO,IAAI,KAAK,CAAT,IAAcA,IAAI,KAAK,EAAvB,IAA6BA,IAAI,KAAK,EAAtC,IAA4CA,IAAI,KAAK,EAA5D,EAAgE;AAC9DL,IAAAA,EAAE;AACH;;AAED,MAAIK,IAAI,KAAK,CAAb,EAAgB;AACdC,IAAAA,IAAI,GAAG,KAAP;AACA;AACD;;AAEDT,EAAAA,KAAK,GAAGC,GAAR;;AAEA,UAAQO,IAAR;AACE;AACA,SAAK,EAAL;AACEC,MAAAA,IAAI,GAAG,QAAP;AACA,aAAOqB,UAAU,EAAjB;AACF;;AAEA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACA,SAAK,EAAL;AACErB,MAAAA,IAAI,GAAG,QAAP;AACA,aAAOsB,UAAU,EAAjB;AACF;;AAEA,SAAK,GAAL;AACE,UAAIlC,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoBA,KAAK,GAAG,CAA5B,MAAmC,OAAvC,EAAgD;AAC9C;AACD;;AAEDC,MAAAA,GAAG,IAAI,CAAP;AACAE,MAAAA,EAAE;AACFM,MAAAA,IAAI,GAAG,SAAP;AACA;AACF;;AAEA,SAAK,GAAL;AACE,UAAIZ,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoBA,KAAK,GAAG,CAA5B,MAAmC,MAAvC,EAA+C;AAC7C;AACD;;AAEDC,MAAAA,GAAG,IAAI,CAAP;AACAE,MAAAA,EAAE;AACFM,MAAAA,IAAI,GAAG,MAAP;AACA;AACF;;AAEA,SAAK,GAAL;AACE,UAAIZ,MAAM,CAAC0B,KAAP,CAAavB,KAAb,EAAoBA,KAAK,GAAG,CAA5B,MAAmC,MAAvC,EAA+C;AAC7C;AACD;;AAEDC,MAAAA,GAAG,IAAI,CAAP;AACAE,MAAAA,EAAE;AACFM,MAAAA,IAAI,GAAG,SAAP;AACA;AApDJ;;AAuDAA,EAAAA,IAAI,GAAGZ,MAAM,CAACG,KAAD,CAAb;AACAG,EAAAA,EAAE;AACH;;AAED,SAAS2B,UAAT,GAAsB;AACpB3B,EAAAA,EAAE;;AAEF,SAAOK,IAAI,KAAK,EAAT,IAAeA,IAAI,GAAG,EAA7B,EAAiC;AAC/B,QAAIA,IAAI,KAAK,EAAb,EAAiB;AACf;AACAL,MAAAA,EAAE;;AAEF,cAAQK,IAAR;AACE,aAAK,EAAL,CADF,CACW;;AAET,aAAK,EAAL,CAHF,CAGW;;AAET,aAAK,EAAL,CALF,CAKW;;AAET,aAAK,EAAL,CAPF,CAOW;;AAET,aAAK,GAAL,CATF,CASY;;AAEV,aAAK,GAAL,CAXF,CAWY;;AAEV,aAAK,GAAL,CAbF,CAaY;;AAEV,aAAK,GAAL;AACE;AACAL,UAAAA,EAAE;AACF;;AAEF,aAAK,GAAL;AACE;AACAA,UAAAA,EAAE;AACF6B,UAAAA,OAAO;AACPA,UAAAA,OAAO;AACPA,UAAAA,OAAO;AACPA,UAAAA,OAAO;AACP;;AAEF;AACE,gBAAMN,WAAW,CAAC,gCAAD,CAAjB;AA9BJ;AAgCD,KApCD,MAoCO,IAAIzB,GAAG,KAAKH,MAAZ,EAAoB;AACzB,YAAM4B,WAAW,CAAC,sBAAD,CAAjB;AACD,KAFM,MAEA;AACLvB,MAAAA,EAAE;AACH;AACF;;AAED,MAAIK,IAAI,KAAK,EAAb,EAAiB;AACfL,IAAAA,EAAE;AACF;AACD;;AAED,QAAMuB,WAAW,CAAC,sBAAD,CAAjB;AACD;;AAED,SAASM,OAAT,GAAmB;AACjB,MAAIxB,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAAtB,IAA4B;AAChCA,EAAAA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EADlB,IACwB;AAC5BA,EAAAA,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,GAFtB,CAE0B;AAF1B,IAGE;AACE,aAAOL,EAAE,EAAT;AACD;;AAEH,QAAMuB,WAAW,CAAC,6BAAD,CAAjB;AACD;;AAED,SAASK,UAAT,GAAsB;AACpB,MAAIvB,IAAI,KAAK,EAAb,EAAiB;AACf;AACAL,IAAAA,EAAE;AACH;;AAED,MAAIK,IAAI,KAAK,EAAb,EAAiB;AACf;AACAL,IAAAA,EAAE;AACH,GAHD,MAGO;AACL8B,IAAAA,UAAU;AACX;;AAED,MAAIzB,IAAI,KAAK,EAAb,EAAiB;AACf;AACAL,IAAAA,EAAE;AACF8B,IAAAA,UAAU;AACX;;AAED,MAAIzB,IAAI,KAAK,EAAT,IAAeA,IAAI,KAAK,GAA5B,EAAiC;AAC/B;AACAL,IAAAA,EAAE;;AAEF,QAAIK,IAAI,KAAK,EAAT,IAAeA,IAAI,KAAK,EAA5B,EAAgC;AAC9B;AACAL,MAAAA,EAAE;AACH;;AAED8B,IAAAA,UAAU;AACX;AACF;;AAED,SAASA,UAAT,GAAsB;AACpB,MAAIzB,IAAI,GAAG,EAAP,IAAaA,IAAI,GAAG,EAAxB,EAA4B;AAC1B;AACA,UAAMkB,WAAW,CAAC,yBAAD,CAAjB;AACD;;AAED,KAAG;AACDvB,IAAAA,EAAE;AACH,GAFD,QAESK,IAAI,IAAI,EAAR,IAAcA,IAAI,IAAI,EAF/B,EANoB,CAQgB;;AAErC","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = jsonParse;\n\n/**\n *  Copyright (c) 2020 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This JSON parser simply walks the input, generating an AST. Use this in lieu\n * of JSON.parse if you need character offset parse errors and an AST parse tree\n * with location information.\n *\n * If an error is encountered, a SyntaxError will be thrown, with properties:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\nfunction jsonParse(str) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  const ast = parseObj();\n  expect('EOF');\n  return ast;\n}\n\nlet string;\nlet strLen;\nlet start;\nlet end;\nlet lastEnd;\nlet code;\nlet kind;\n\nfunction parseObj() {\n  const nodeStart = start;\n  const members = [];\n  expect('{');\n\n  if (!skip('}')) {\n    do {\n      members.push(parseMember());\n    } while (skip(','));\n\n    expect('}');\n  }\n\n  return {\n    kind: 'Object',\n    start: nodeStart,\n    end: lastEnd,\n    members\n  };\n}\n\nfunction parseMember() {\n  const nodeStart = start;\n  const key = kind === 'String' ? curToken() : null;\n  expect('String');\n  expect(':');\n  const value = parseVal();\n  return {\n    kind: 'Member',\n    start: nodeStart,\n    end: lastEnd,\n    key,\n    value\n  };\n}\n\nfunction parseArr() {\n  const nodeStart = start;\n  const values = [];\n  expect('[');\n\n  if (!skip(']')) {\n    do {\n      values.push(parseVal());\n    } while (skip(','));\n\n    expect(']');\n  }\n\n  return {\n    kind: 'Array',\n    start: nodeStart,\n    end: lastEnd,\n    values\n  };\n}\n\nfunction parseVal() {\n  switch (kind) {\n    case '[':\n      return parseArr();\n\n    case '{':\n      return parseObj();\n\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n      const token = curToken();\n      lex();\n      return token;\n  }\n\n  return expect('Value');\n}\n\nfunction curToken() {\n  return {\n    kind,\n    start,\n    end,\n    value: JSON.parse(string.slice(start, end))\n  };\n}\n\nfunction expect(str) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n\n  let found;\n\n  if (kind === 'EOF') {\n    found = '[end of file]';\n  } else if (end - start > 1) {\n    found = '`' + string.slice(start, end) + '`';\n  } else {\n    const match = string.slice(start).match(/^.+?\\b/);\n    found = '`' + (match ? match[0] : string[start]) + '`';\n  }\n\n  throw syntaxError(`Expected ${str} but found ${found}.`);\n}\n\nfunction syntaxError(message) {\n  return {\n    message,\n    start,\n    end\n  };\n}\n\nfunction skip(k) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n}\n\nfunction lex() {\n  lastEnd = end;\n\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -, 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = 'Number';\n      return readNumber();\n    // f\n\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n\n      end += 4;\n      ch();\n      kind = 'Boolean';\n      return;\n    // n\n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Null';\n      return;\n    // t\n\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Boolean';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n\n  while (code !== 34 && code > 31) {\n    if (code === 92) {\n      // \\\n      ch();\n\n      switch (code) {\n        case 34: // \"\n\n        case 47: // /\n\n        case 92: // \\\n\n        case 98: // b\n\n        case 102: // f\n\n        case 110: // n\n\n        case 114: // r\n\n        case 116:\n          // t\n          ch();\n          break;\n\n        case 117:\n          // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    } else {\n      ch();\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 70 || // A-F\n  code >= 97 && code <= 102 // a-f\n  ) {\n      return ch();\n    }\n\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    ch();\n\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n\n}"]},"metadata":{},"sourceType":"script"}