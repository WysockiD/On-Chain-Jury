import SturdyWebSocket from 'sturdy-websocket';
import CryptoEs from 'crypto-es';
const networks = {
  bitcoin: {
    '1': 'main',
    '2': 'testnet'
  },
  ethereum: {
    '1': 'main',
    '3': 'ropsten',
    '4': 'rinkeby',
    '5': 'goerli',
    '42': 'kovan',
    '100': 'xdai'
  }
};
const DEFAULT_RATE_LIMIT_RULES = {
  points: 150,
  duration: 1
};
const QUEUE_LIMIT = 10000;

function createEmitter() {
  return {
    listeners: {},
    on: function (eventCode, listener) {
      // check if valid eventCode
      switch (eventCode) {
        case 'txSent':
        case 'txPool':
        case 'txConfirmed':
        case 'txSpeedUp':
        case 'txCancel':
        case 'txFailed':
        case 'all':
          break;

        default:
          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);
      } // check that listener is a function


      if (typeof listener !== 'function') {
        throw new Error('Listener must be a function');
      } // add listener for the eventCode


      this.listeners[eventCode] = listener;
    },
    emit: function (state) {
      if (this.listeners[state.eventCode]) {
        return this.listeners[state.eventCode](state);
      }

      if (this.listeners.all) {
        return this.listeners.all(state);
      }
    }
  };
}

function networkName(blockchain, id) {
  return networks[blockchain][id];
}

function serverEcho(eventCode) {
  switch (eventCode) {
    case 'txRequest':
    case 'nsfFail':
    case 'txRepeat':
    case 'txAwaitingApproval':
    case 'txConfirmReminder':
    case 'txSendFail':
    case 'txError':
    case 'txUnderPriced':
    case 'txSent':
      return true;

    default:
      return false;
  }
}

function last(arr) {
  return arr.reverse()[0];
} // isAddress and isTxid are not meant to perform real validation,
// just needs to work out if it is an address or a transaction id
// the server will do more thorough validation


function isAddress(blockchain, addressOrHash) {
  switch (blockchain) {
    case 'ethereum':
      return addressOrHash.length === 42;

    case 'bitcoin':
      return addressOrHash.length !== 64;

    default:
      return false;
  }
}

function isTxid(blockchain, addressOrHash) {
  switch (blockchain) {
    case 'ethereum':
      return addressOrHash.length === 66;

    case 'bitcoin':
      return addressOrHash.length === 64;

    default:
      return false;
  }
}

function wait(time) {
  return new Promise(resolve => {
    setTimeout(resolve, time);
  });
}

function transaction(hash, id) {
  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction

  const startTime = Date.now(); // create emitter for transaction

  const emitter = createEmitter(); // create eventCode for transaction

  const eventCode = 'txSent'; // put in queue

  this._watchedTransactions.push({
    hash,
    emitter
  });

  const transaction = {
    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,
    id: id || hash,
    startTime,
    status: 'sent'
  };
  const newState = { ...transaction,
    eventCode
  }; // logEvent to server

  this._sendMessage({
    eventCode,
    categoryCode: 'activeTransaction',
    transaction
  });

  const transactionObj = {
    details: transaction,
    emitter
  };

  function emitState() {
    const emitterResult = emitter.emit(newState);

    this._transactionHandlers.forEach(handler => handler({
      transaction: newState,
      emitterResult
    }));
  } // emit after delay to allow for listener to be registered


  setTimeout(emitState.bind(this), 5);
  return transactionObj;
}

function account(address) {
  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum

  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction

  const emitter = createEmitter(); // create eventCode for transaction

  const eventCode = 'watch';

  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);

  if (existingAddressWatcher) {
    // add to existing emitters array
    existingAddressWatcher.emitters.push(emitter);
  } else {
    // put in accounts queue
    this._watchedAccounts.push({
      address,
      emitters: [emitter]
    });
  } // logEvent to server


  this._sendMessage({
    eventCode,
    categoryCode: 'accountAddress',
    account: {
      address
    }
  });

  return {
    emitter,
    details: {
      address
    }
  };
}

function event(eventObj) {
  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');

  this._sendMessage(eventObj);
}

function unsubscribe(addressOrHash) {
  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');
  const address = isAddress(this._system, addressOrHash);
  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash

  if (address) {
    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts

    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server

    this._sendMessage({
      categoryCode: 'accountAddress',
      eventCode: 'unwatch',
      account: {
        address: normalizedAddress
      }
    });
  } else if (txid) {
    // remove transaction from transactions
    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server

    this._sendMessage({
      categoryCode: 'activeTransaction',
      eventCode: 'unwatch',
      transaction: {
        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,
        id: addressOrHash,
        status: 'unsubscribed'
      }
    });
  } else {
    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);
  }
}

var version = "2.1.5";

function sendMessage(msg) {
  if (this._queuedMessages.length > QUEUE_LIMIT) {
    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);
  }

  this._queuedMessages.push(createEventLog.bind(this)(msg));

  if (!this._processingQueue) {
    this._processQueue();
  }
}

async function processQueue() {
  this._processingQueue = true;

  if (!this._connected) {
    await waitForConnectionOpen.bind(this)();
  }

  while (this._queuedMessages.length > 0) {
    // small wait to allow response from server to take affect
    await wait(1);

    if (this._waitToRetry !== null) {
      // have been rate limited so wait
      await this._waitToRetry;
      this._waitToRetry = null;
    }

    const msg = this._queuedMessages.shift();

    const delay = this._limitRules.duration / this._limitRules.points * 1000;
    await wait(delay);

    this._socket.send(msg);
  }

  this._processingQueue = false;
  this._limitRules = DEFAULT_RATE_LIMIT_RULES;
}

function handleMessage(msg) {
  const {
    status,
    reason,
    event,
    connectionId,
    retryMs,
    limitRules,
    blockedMsg
  } = JSON.parse(msg.data);

  if (connectionId) {
    if (typeof window !== 'undefined') {
      window.localStorage.setItem(this._storageKey, connectionId);
    }

    this._connectionId = connectionId;
  } // handle any errors from the server


  if (status === 'error') {
    if (reason.includes('ratelimit')) {
      this._waitToRetry = wait(retryMs);
      this._limitRules = limitRules; // add blocked msg to the front of the queue

      blockedMsg && this._queuedMessages.unshift(blockedMsg);
      return;
    }

    if (reason.includes('not a valid API key')) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });

        return;
      } else {
        throw new Error(reason);
      }
    }

    if (reason.includes('network not supported')) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });

        return;
      } else {
        throw new Error(reason);
      }
    }

    if (reason.includes('maximum allowed amount')) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // handle bitcoin txid error


    if (reason.includes('invalid txid')) {
      const reason = `${event.transaction.txid} is an invalid txid`;

      if (this._onerror) {
        this._onerror({
          message: reason,
          transaction: event.transaction.txid
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // handle ethereum transaction hash error


    if (reason.includes('invalid hash')) {
      const reason = `${event.transaction.hash} is an invalid transaction hash`;

      if (this._onerror) {
        this._onerror({
          message: reason,
          transaction: event.transaction.hash
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // handle general address error


    if (reason.includes('invalid address')) {
      const reason = `${event.account.address} is an invalid address`;

      if (this._onerror) {
        this._onerror({
          message: reason,
          account: event.account.address
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // handle bitcoin specific address error


    if (reason.includes('not a valid Bitcoin')) {
      if (this._onerror) {
        this._onerror({
          message: reason,
          account: event.account.address
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // handle ethereum specific address error


    if (reason.includes('not a valid Ethereum')) {
      if (this._onerror) {
        this._onerror({
          message: reason,
          account: event.account.address
        });

        return;
      } else {
        throw new Error(reason);
      }
    } // throw error that comes back from the server without formatting the message


    if (this._onerror) {
      this._onerror({
        message: reason
      });

      return;
    } else {
      throw new Error(reason);
    }
  }

  if (event && event.transaction) {
    const {
      transaction,
      eventCode,
      contractCall
    } = event; // flatten in to one object

    const newState = this._system === 'ethereum' ? { ...transaction,
      eventCode,
      contractCall
    } : { ...transaction,
      eventCode
    }; // ignore server echo and unsubscribe messages

    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {
      return;
    } // handle change of hash in speedup and cancel events


    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {
      this._watchedTransactions = this._watchedTransactions.map(tx => {
        if (tx.hash === transaction.originalHash) {
          // reassign hash parameter in transaction queue to new hash or txid
          tx.hash = transaction.hash || transaction.txid;
        }

        return tx;
      });
    }

    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;

    if (watchedAddress) {
      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);

      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;

      this._transactionHandlers.forEach(handler => handler({
        transaction: newState,
        emitterResult
      }));
    } else {
      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);

      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);

      this._transactionHandlers.forEach(handler => handler({
        transaction: newState,
        emitterResult
      }));
    }
  }
}

function createEventLog(msg) {
  return JSON.stringify({
    timeStamp: new Date(),
    dappId: this._dappId,
    version,
    blockchain: {
      system: this._system,
      network: networkName(this._system, this._networkId) || 'local'
    },
    ...msg
  });
}

function waitForConnectionOpen() {
  return new Promise(resolve => {
    const interval = setInterval(() => {
      if (this._connected) {
        setTimeout(resolve, 100);
        clearInterval(interval);
      }
    });
  });
}

function validateType(options) {
  const {
    name,
    value,
    type,
    optional,
    customValidation
  } = options;

  if (!optional && typeof value === 'undefined') {
    throw new Error(`"${name}" is required`);
  }

  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {
    throw new Error(`"${name}" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);
  }

  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {
    throw new Error(`"${value}" is not a valid "${name}"`);
  }
}

function validateOptions(options) {
  validateType({
    name: 'sdk options',
    value: options,
    type: 'object'
  });
  const {
    dappId,
    system,
    name,
    networkId,
    transactionHandlers,
    apiUrl,
    ws,
    onopen,
    ondown,
    onreopen,
    onerror,
    onclose,
    ...otherParams
  } = options;
  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');
  validateType({
    name: 'dappId',
    value: dappId,
    type: 'string'
  });
  validateType({
    name: 'system',
    value: system,
    type: 'string',
    optional: true,
    customValidation: validSystem
  });
  validateType({
    name: 'name',
    value: name,
    type: 'string',
    optional: true
  });
  validateType({
    name: 'networkId',
    value: networkId,
    type: 'number'
  });
  validateType({
    name: 'transactionHandler',
    value: transactionHandlers,
    type: 'array',
    optional: true
  });

  if (transactionHandlers) {
    transactionHandlers.forEach(handler => validateType({
      name: 'transactionHandler',
      value: handler,
      type: 'function'
    }));
  }

  validateType({
    name: 'apiUrl',
    value: apiUrl,
    type: 'string',
    optional: true
  });
  validateType({
    name: 'ws',
    value: ws,
    type: 'function',
    optional: true
  });
  validateType({
    name: 'onopen',
    value: onopen,
    type: 'function',
    optional: true
  });
  validateType({
    name: 'ondown',
    value: ondown,
    type: 'function',
    optional: true
  });
  validateType({
    name: 'onreopen',
    value: onreopen,
    type: 'function',
    optional: true
  });
  validateType({
    name: 'onerror',
    value: onerror,
    type: 'function',
    optional: true
  });
  validateType({
    name: 'onclose',
    value: onclose,
    type: 'function',
    optional: true
  });
}

function validSystem(system) {
  return !!networks[system];
}

function invalidParams(params, validParams, functionName) {
  const invalid = Object.keys(params);

  if (invalid.length > 0) {
    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);
  }
}

const DEFAULT_NAME = 'unknown';
const DEFAULT_SYSTEM = 'ethereum';

class Blocknative {
  constructor(options) {
    validateOptions(options);
    const {
      dappId,
      system = DEFAULT_SYSTEM,
      name = DEFAULT_NAME,
      networkId,
      transactionHandlers = [],
      apiUrl,
      ws,
      onopen,
      ondown,
      onreopen,
      onerror,
      onclose
    } = options;
    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {
      wsConstructor: ws
    } : {});
    socket.onopen = onOpen.bind(this, onopen);
    socket.ondown = onDown.bind(this, ondown);
    socket.onreopen = onReopen.bind(this, onreopen);
    socket.onmessage = handleMessage.bind(this);

    socket.onerror = error => onerror && onerror({
      message: 'There was a WebSocket error',
      error
    });

    socket.onclose = () => {
      this._pingTimeout && clearInterval(this._pingTimeout);
      onclose && onclose();
    };

    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();
    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);
    this._storageKey = storageKey;
    this._connectionId = storedConnectionId || undefined;
    this._dappId = dappId;
    this._system = system;
    this._networkId = networkId;
    this._transactionHandlers = transactionHandlers;
    this._socket = socket;
    this._connected = false;
    this._sendMessage = sendMessage.bind(this);
    this._watchedTransactions = [];
    this._watchedAccounts = [];
    this._pingTimeout = undefined;
    this._destroyed = false;
    this._onerror = onerror;
    this._queuedMessages = [];
    this._limitRules = DEFAULT_RATE_LIMIT_RULES;
    this._waitToRetry = null;
    this._processingQueue = false;
    this._processQueue = processQueue.bind(this);

    if (this._socket.ws.on) {
      this._heartbeat = () => {
        this._pingTimeout && clearTimeout(this._pingTimeout);
        this._pingTimeout = setTimeout(() => {
          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay
          // Sturdy Websocket will handle the new connection logic
          this._socket.ws.terminate();
        }, 30000 + 1000);
      };

      this._socket.ws.on('ping', () => {
        this._heartbeat && this._heartbeat();
      });
    } // public API


    this.transaction = transaction.bind(this);
    this.account = account.bind(this);
    this.event = event.bind(this);
    this.unsubscribe = unsubscribe.bind(this);

    this.destroy = () => {
      this._socket.close();

      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected
      // https://github.com/dphilipson/sturdy-websocket/issues/5

      this._socket.onclose();
    };
  }

}

function onOpen(handler) {
  this._connected = true;
  const msg = {
    categoryCode: 'initialize',
    eventCode: 'checkDappId',
    connectionId: this._connectionId
  }; // send this message directly rather than put in queue

  this._socket.send(createEventLog.bind(this)(msg));

  this._heartbeat && this._heartbeat();
  handler && handler();
}

function onDown(handler, closeEvent) {
  this._connected = false;

  if (handler) {
    handler(closeEvent);
  }

  this._pingTimeout && clearTimeout(this._pingTimeout);
}

function onReopen(handler) {
  this._connected = true;
  const msg = {
    categoryCode: 'initialize',
    eventCode: 'checkDappId',
    connectionId: this._connectionId
  };

  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon
  // re-connection as they don't get transferred over automatically
  // to the new connection like tx hashes do


  this._watchedAccounts.forEach(account => {
    this._sendMessage({
      eventCode: 'accountAddress',
      categoryCode: 'watch',
      account: {
        address: account.address
      }
    });
  });

  if (handler) {
    handler();
  }

  if (this._socket.ws.on) {
    // need to re-register ping event since new connection
    this._socket.ws.on('ping', () => {
      this._heartbeat && this._heartbeat();
    });

    this._heartbeat();
  }
}

export default Blocknative;
